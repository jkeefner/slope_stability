<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slope Stability Analyzer - Keefner Mining & Geotech</title>
    
    <!-- PWA Meta Tags -->
    <meta name="description" content="Circular failure slope stability analysis using Modified Bishop's Method - Keefner Mining & Geotech LLC">
    <meta name="theme-color" content="#ff9e64">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Slope Stability">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icons/icon-192.png">
    
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;800&family=IBM+Plex+Sans:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0e14;
            --bg-secondary: #151920;
            --bg-tertiary: #1f2430;
            --accent-primary: #00d4aa;
            --accent-danger: #f7768e;
            --accent-safe: #9ece6a;
            --accent-warning: #e0af68;
            --accent-blue: #7aa2f7;
            --accent-purple: #bb9af7;
            --accent-teal: #00d4aa;
            --text-primary: #c0caf5;
            --text-secondary: #a9b1d6;
            --text-dim: #565f89;
            --border: #2a2e38;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        .header {
            background: var(--bg-secondary);
            border-bottom: 3px solid var(--accent-teal);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1.5rem;
        }

        .header-logo {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header-logo svg {
            height: 40px;
            width: auto;
        }

        .header-brand {
            display: flex;
            flex-direction: column;
        }

        .header-brand .company {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--accent-teal);
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        .header-brand .product {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 800;
            color: var(--text-primary);
            letter-spacing: -0.01em;
        }

        .header h1 {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 800;
            letter-spacing: -0.02em;
            text-transform: uppercase;
            color: var(--accent-primary);
        }

        .header .subtitle {
            font-size: 0.85rem;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            margin-top: 0.25rem;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 420px 1fr;
            gap: 2rem;
            min-height: calc(100vh - 120px);
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1.5rem;
            height: fit-content;
            max-height: calc(100vh - 140px);
            overflow-y: auto;
        }

        .panel-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 1.5rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .section-header {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--accent-primary);
            margin: 1.5rem 0 1rem 0;
            padding: 0.5rem;
            background: rgba(255, 158, 100, 0.1);
            border-radius: 3px;
        }

        .section-header:first-of-type { margin-top: 0; }

        .input-group { margin-bottom: 1rem; }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .input-row-3 {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 0.5rem;
        }

        .input-label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 0.4rem;
            color: var(--text-secondary);
            font-family: 'JetBrains Mono', monospace;
        }

        .input-sublabel {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-top: 0.2rem;
        }

        input[type="number"], input[type="range"], select {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.6rem;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            transition: all 0.2s;
        }

        input[type="number"]:focus, select:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(255, 158, 100, 0.1);
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            border-radius: 3px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: var(--accent-primary);
            border-radius: 50%;
            cursor: pointer;
        }

        .range-value {
            display: inline-block;
            background: var(--bg-tertiary);
            color: var(--accent-primary);
            padding: 0.2rem 0.5rem;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 0.6rem;
            cursor: pointer;
            accent-color: var(--accent-primary);
        }

        .checkbox-group label {
            font-size: 0.85rem;
            cursor: pointer;
            font-family: 'JetBrains Mono', monospace;
        }

        .button {
            width: 100%;
            padding: 0.9rem;
            background: var(--accent-primary);
            color: var(--bg-primary);
            border: none;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 800;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 0.05em;
            margin-top: 1rem;
        }

        .button:hover {
            background: #ffb380;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255, 158, 100, 0.3);
        }

        .button-secondary {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .button-secondary:hover {
            background: var(--bg-tertiary);
            border-color: var(--accent-primary);
            color: var(--accent-primary);
            box-shadow: none;
        }

        .button-small {
            padding: 0.5rem 0.75rem;
            font-size: 0.75rem;
            margin-top: 0;
        }

        /* Advanced Options Toggle */
        .advanced-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 3px;
            cursor: pointer;
            margin: 1rem 0;
            transition: all 0.2s;
        }

        .advanced-toggle:hover {
            border-color: var(--accent-purple);
        }

        .advanced-toggle .label {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .advanced-toggle .icon {
            font-size: 1.2rem;
            color: var(--accent-purple);
            transition: transform 0.2s;
        }

        .advanced-toggle.active .icon {
            transform: rotate(180deg);
        }

        .advanced-content {
            display: none;
            border: 1px solid var(--accent-purple);
            border-radius: 3px;
            padding: 1rem;
            margin-bottom: 1rem;
            background: rgba(187, 154, 247, 0.05);
        }

        .advanced-content.show { display: block; }

        /* Segment Cards */
        .segment-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 0.75rem;
            position: relative;
        }

        .segment-card.active {
            border-color: var(--accent-primary);
        }

        .segment-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .segment-title {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .segment-info {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-dim);
        }

        .segment-delete {
            background: none;
            border: none;
            color: var(--accent-danger);
            cursor: pointer;
            font-size: 1.1rem;
            padding: 0.25rem;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .segment-delete:hover { opacity: 1; }

        .segment-elevation-bar {
            background: var(--bg-primary);
            padding: 0.35rem 0.6rem;
            border-radius: 3px;
            margin-bottom: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
            color: var(--accent-blue);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .add-segment-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
            padding: 0.75rem;
            background: transparent;
            border: 2px dashed var(--border);
            border-radius: 4px;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-segment-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .height-indicator {
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 0.5rem 0.75rem;
            margin-bottom: 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .height-indicator .used {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--accent-safe);
        }

        .height-indicator .remaining {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .height-indicator.over .used {
            color: var(--accent-danger);
        }

        /* Stepout options */
        .stepout-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px dashed var(--border);
        }

        .stepout-type {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }

        .stepout-type label {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.4rem;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 3px;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }

        .stepout-type input[type="radio"] {
            display: none;
        }

        .stepout-type input[type="radio"]:checked + label {
            border-color: var(--accent-blue);
            background: rgba(122, 162, 247, 0.1);
            color: var(--accent-blue);
        }

        /* Results and visualization styles from before */
        .results-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .result-primary {
            margin-bottom: 1rem;
        }

        .fos-card {
            background: var(--bg-tertiary);
            border: 2px solid var(--border);
            border-radius: 4px;
            padding: 1rem;
            text-align: center;
        }

        .fos-card .result-value {
            font-size: 2.5rem;
        }

        .result-sublabel {
            font-size: 0.75rem;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            margin-top: 0.25rem;
        }

        .result-section {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .result-section-header {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-family: 'JetBrains Mono', monospace;
            margin-bottom: 0.5rem;
            padding-bottom: 0.4rem;
            border-bottom: 1px solid var(--border);
        }

        .result-grid-compact {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.5rem;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.3rem 0;
        }

        .result-item-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }

        .result-item-value {
            font-size: 0.85rem;
            font-weight: 600;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-primary);
        }

        .volume-input-row {
            display: flex;
            gap: 0.75rem;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px dashed var(--border);
        }

        .volume-input-row input {
            padding: 0.3rem 0.5rem;
            font-size: 0.8rem;
            width: 100%;
        }

        .volume-highlight {
            color: var(--accent-safe) !important;
            font-weight: 700 !important;
        }

        .result-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .result-card {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 0.75rem;
        }

        .result-label {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-family: 'JetBrains Mono', monospace;
        }

        .result-value {
            font-size: 1.4rem;
            font-weight: 800;
            font-family: 'JetBrains Mono', monospace;
            margin-top: 0.2rem;
        }

        .result-value.safe { color: var(--accent-safe); }
        .result-value.warning { color: var(--accent-warning); }
        .result-value.danger { color: var(--accent-danger); }
        .result-unit { font-size: 0.75rem; color: var(--text-dim); }

        .canvas-container {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        canvas {
            width: 100%;
            height: auto;
            display: block;
            border-radius: 3px;
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .legend-item {
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 2px;
            margin-right: 0.4rem;
            border: 1px solid var(--border);
        }

        .warning-banner, .info-banner {
            border-radius: 3px;
            padding: 0.75rem;
            margin-bottom: 1rem;
            font-size: 0.8rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .warning-banner {
            background: rgba(247, 118, 142, 0.1);
            border: 1px solid var(--accent-danger);
            color: var(--accent-danger);
        }

        .info-banner {
            background: rgba(158, 206, 106, 0.1);
            border: 1px solid var(--accent-safe);
            color: var(--accent-safe);
        }

        /* Calculation panel */
        .calc-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .equation-box {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .equation-main {
            font-size: 1rem;
            color: var(--accent-primary);
            text-align: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid var(--border);
        }

        .equation-terms {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 0.75rem;
            margin-top: 0.75rem;
        }

        .equation-term {
            padding: 0.5rem;
            background: var(--bg-primary);
            border-radius: 3px;
            font-size: 0.75rem;
        }

        .equation-term .symbol { color: var(--accent-primary); font-weight: 600; }
        .equation-term .value { color: var(--accent-safe); float: right; }
        .equation-term .description { font-size: 0.65rem; color: var(--text-dim); margin-top: 0.2rem; }

        .slice-table-container {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 1rem;
            border: 1px solid var(--border);
            border-radius: 4px;
        }

        .slice-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.7rem;
        }

        .slice-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.5rem 0.4rem;
            text-align: right;
            position: sticky;
            top: 0;
            border-bottom: 2px solid var(--accent-primary);
        }

        .slice-table th:first-child { text-align: center; }
        .slice-table td { padding: 0.4rem; text-align: right; border-bottom: 1px solid var(--border); }
        .slice-table td:first-child { text-align: center; color: var(--text-dim); }
        .slice-table tr:hover { background: rgba(255, 158, 100, 0.05); }
        .slice-table .sum-row { background: var(--bg-tertiary); font-weight: 600; }
        .slice-table .sum-row td { border-top: 2px solid var(--accent-primary); color: var(--accent-primary); }

        .summary-calc {
            background: var(--bg-tertiary);
            border: 2px solid var(--accent-primary);
            border-radius: 4px;
            padding: 1rem;
            margin-top: 1rem;
            text-align: center;
        }

        .summary-calc .final-equation { font-size: 1rem; color: var(--text-primary); margin-bottom: 0.5rem; }
        .summary-calc .final-result { font-size: 1.8rem; font-weight: 800; font-family: 'JetBrains Mono', monospace; }

        .toggle-details {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 0.5rem 1rem;
            border-radius: 3px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            cursor: pointer;
            margin-top: 0.75rem;
        }

        .toggle-details:hover { border-color: var(--accent-primary); color: var(--accent-primary); }
        .collapsible { display: none; }
        .collapsible.show { display: block; }

        /* Volume estimation */
        .volume-section {
            margin-top: 1rem;
            padding: 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
            border: 1px solid var(--border);
        }

        @media (max-width: 1200px) {
            .container { grid-template-columns: 1fr; }
            .panel { max-height: none; }
        }

        /* Limit range display */
        .limit-range-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.4rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .limit-range-display span {
            min-width: 45px;
            text-align: center;
            color: var(--accent-primary);
            font-weight: 600;
        }

        .limit-bar {
            flex: 1;
            height: 8px;
            background: var(--bg-primary);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .limit-bar-fill {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, rgba(247,118,142,0.4), rgba(247,118,142,0.6));
            border-radius: 4px;
            transition: left 0.1s, width 0.1s;
        }

        .limit-bar-zero {
            position: absolute;
            left: 50%;
            top: 0;
            bottom: 0;
            width: 2px;
            background: var(--text-dim);
            transform: translateX(-50%);
        }

        /* Sensitivity Analysis */
        .sensitivity-panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1.5rem;
            margin-bottom: 2rem;
        }

        .sensitivity-controls {
            display: grid;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }

        .sensitivity-chart-container {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .sensitivity-chart-container canvas {
            width: 100%;
            height: auto;
        }

        .sensitivity-table-container {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .sensitivity-table {
            width: 100%;
            border-collapse: collapse;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .sensitivity-table th {
            background: var(--bg-tertiary);
            color: var(--text-secondary);
            padding: 0.6rem;
            text-align: right;
            position: sticky;
            top: 0;
            border-bottom: 2px solid var(--accent-purple);
        }

        .sensitivity-table th:first-child {
            text-align: left;
        }

        .sensitivity-table td {
            padding: 0.5rem 0.6rem;
            text-align: right;
            border-bottom: 1px solid var(--border);
        }

        .sensitivity-table td:first-child {
            text-align: left;
        }

        .sensitivity-table tr:hover {
            background: rgba(187, 154, 247, 0.05);
        }

        .sensitivity-table tr.baseline {
            background: rgba(187, 154, 247, 0.15);
            font-weight: 600;
        }

        .sensitivity-table .status-safe { color: var(--accent-safe); }
        .sensitivity-table .status-warning { color: var(--accent-warning); }
        .sensitivity-table .status-danger { color: var(--accent-danger); }

        .sensitivity-summary {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-purple);
            border-radius: 4px;
            padding: 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .sensitivity-summary .title {
            color: var(--accent-purple);
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .sensitivity-summary .stat {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border);
        }

        .sensitivity-summary .stat:last-child {
            border-bottom: none;
        }

        .sensitivity-summary .stat-label {
            color: var(--text-dim);
        }

        .sensitivity-summary .stat-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        /* Ru guide styling */
        .ru-guide {
            font-size: 0.7rem;
            line-height: 1.5;
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 4px;
        }

        /* Help button in section header */
        .section-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .help-btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-purple);
            color: var(--accent-purple);
            width: 22px;
            height: 22px;
            border-radius: 50%;
            font-size: 0.75rem;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .help-btn:hover {
            background: var(--accent-purple);
            color: var(--bg-primary);
        }

        /* Import/Export section */
        .io-section {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .io-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.5rem;
        }

        .io-buttons .button {
            font-size: 0.75rem;
            padding: 0.5rem;
        }

        .io-hint {
            font-size: 0.65rem;
            color: var(--text-dim);
            text-align: center;
            margin-top: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .button-secondary {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-secondary);
        }

        .button-secondary:hover {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }

        .button-secondary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Preset buttons */
        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            margin-top: 0.5rem;
        }

        .preset-btn {
            padding: 0.5rem 0.25rem;
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }

        .preset-btn.active {
            background: rgba(187, 154, 247, 0.15);
            border-color: var(--accent-purple);
            color: var(--accent-purple);
        }

        /* Constraint group */
        .constraint-group {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 0.75rem;
            margin: 0.75rem 0;
        }

        .constraint-summary {
            font-size: 0.7rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-dim);
            text-align: center;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px dashed var(--border);
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border: 1px solid var(--accent-purple);
            border-radius: 8px;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--accent-purple);
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-dim);
            font-size: 1.5rem;
            cursor: pointer;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--accent-danger);
        }

        .modal-body {
            padding: 1.5rem;
        }

        .modal-body canvas {
            width: 100%;
            height: auto;
            border: 1px solid var(--border);
            border-radius: 4px;
            margin-bottom: 1rem;
        }

        .help-legend {
            display: grid;
            gap: 0.75rem;
            margin-bottom: 1rem;
        }

        .help-item {
            font-size: 0.8rem;
            color: var(--text-secondary);
            line-height: 1.4;
        }

        .help-item strong {
            color: var(--accent-blue);
        }

        .preset-descriptions {
            background: var(--bg-tertiary);
            border-radius: 4px;
            padding: 0.75rem;
        }

        .preset-desc {
            font-size: 0.75rem;
            color: var(--text-dim);
            margin-bottom: 0.5rem;
        }

        .preset-desc:last-child {
            margin-bottom: 0;
        }

        .preset-name {
            color: var(--accent-purple);
            font-weight: 600;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <div class="header-logo">
                <img src="icons/icon-96.png" alt="Keefner Mining" style="width: 48px; height: 48px; border-radius: 4px;">
            </div>
            <div class="header-brand">
                <span class="company">Keefner Mining & Geotech LLC</span>
                <span class="product">Slope Stability Analyzer</span>
            </div>
        </div>
        <div class="header-method">
            <span style="font-family: 'JetBrains Mono', monospace; font-size: 0.75rem; color: var(--text-dim);">
                Modified Bishop's Method ‚Ä¢ Imperial Units
            </span>
        </div>
    </div>

    <div class="container">
        <div class="panel">
            <!-- BASIC SLOPE GEOMETRY -->
            <div class="section-header">üìê Slope Geometry</div>
            
            <div class="input-group">
                <label class="input-label">Overall Slope Height, H (ft)</label>
                <input type="number" id="slopeHeight" value="200" min="10" max="2000" step="10">
            </div>

            <div id="simpleGeometry">
                <div class="input-group">
                    <label class="input-label">
                        Overall Slope Angle, Œ≤ (degrees)
                        <span class="range-value" id="slopeAngleValue">45¬∞</span>
                    </label>
                    <input type="range" id="slopeAngle" value="45" min="15" max="80" step="1">
                </div>
            </div>

            <!-- ADVANCED OPTIONS TOGGLE -->
            <div class="advanced-toggle" id="advancedToggle" onclick="toggleAdvanced()">
                <span class="label">‚ö° Advanced: Multi-Bench Configuration</span>
                <span class="icon">‚ñº</span>
            </div>

            <!-- ADVANCED CONTENT -->
            <div class="advanced-content" id="advancedContent">
                <div class="height-indicator" id="heightIndicator">
                    <div>
                        <span class="used">Used: <span id="usedHeight">0</span> ft</span>
                        <span class="remaining" style="margin-left: 1rem;">Remaining: <span id="remainingHeight">200</span> ft</span>
                    </div>
                    <span id="heightStatus" style="font-size: 0.75rem;"></span>
                </div>

                <div id="segmentsContainer"></div>

                <button class="add-segment-btn" onclick="addSegment()">
                    <span style="font-size: 1.2rem;">+</span> Add Slope Segment
                </button>
            </div>

            <!-- SIMPLE MATERIAL PARAMETERS (shown when not using advanced) -->
            <div id="simpleMaterial">
                <div class="section-header">ü™® Material Properties</div>

                <div class="input-group">
                    <label class="input-label">Material Preset</label>
                    <select id="materialType" onchange="updateMaterialProperties()">
                        <option value="custom">Custom Material</option>
                        <optgroup label="Rock Materials">
                            <option value="hard_rock">Hard Rock (Intact)</option>
                            <option value="weathered_rock">Weathered Rock</option>
                            <option value="fractured_rock">Fractured Rock Mass</option>
                            <option value="shale">Shale/Mudstone</option>
                        </optgroup>
                        <optgroup label="Soil Materials">
                            <option value="dense_sand">Dense Sand/Gravel</option>
                            <option value="loose_sand">Loose Sand</option>
                            <option value="stiff_clay">Stiff Clay</option>
                            <option value="soft_clay">Soft Clay</option>
                        </optgroup>
                        <optgroup label="Mining Materials">
                            <option value="waste_rock">Waste Rock Dump</option>
                            <option value="heap_leach">Heap Leach Material</option>
                        </optgroup>
                    </select>
                </div>

                <div class="input-row">
                    <div class="input-group">
                        <label class="input-label">Cohesion, c' (psf)</label>
                        <input type="number" id="cohesion" value="300" min="0" max="10000" step="10">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Unit Weight, Œ≥ (pcf)</label>
                        <input type="number" id="unitWeight" value="125" min="90" max="180" step="1">
                    </div>
                </div>

                <div class="input-group">
                    <label class="input-label">
                        Friction Angle, œÜ' (degrees)
                        <span class="range-value" id="frictionAngleValue">30¬∞</span>
                    </label>
                    <input type="range" id="frictionAngle" value="30" min="0" max="50" step="1">
                </div>
            </div>

            <!-- HYDROGEOLOGY - NEW SECTION -->
            <div class="section-header">üíß Hydrogeology</div>
            
            <div class="input-group">
                <label class="input-label">Pore Pressure Model</label>
                <select id="porePressureModel" onchange="updatePorePressureUI()">
                    <option value="none">No Pore Pressure (Dry)</option>
                    <option value="watertable">Water Table</option>
                    <option value="ru">Ru Coefficient</option>
                    <option value="combined">Combined (Water Table + Ru)</option>
                </select>
            </div>
            
            <div id="waterTableControls" style="display: none;">
                <div class="input-group">
                    <label class="input-label">
                        Water Table Depth (ft below crest)
                        <span class="range-value" id="waterTableValue">50 ft</span>
                    </label>
                    <input type="range" id="waterTable" value="50" min="0" max="400" step="5">
                </div>
            </div>
            
            <div id="ruControls" style="display: none;">
                <div class="input-group">
                    <label class="input-label">
                        Ru Coefficient (u/œÉv)
                        <span class="range-value" id="ruValue">0.15</span>
                    </label>
                    <input type="range" id="ruCoeff" value="0.15" min="0" max="0.5" step="0.01" oninput="document.getElementById('ruValue').textContent = this.value">
                    <div class="input-sublabel ru-guide">
                        <span style="color: var(--accent-safe);">0.0-0.1: Well-drained/Depressurized</span><br>
                        <span style="color: var(--accent-blue);">0.1-0.2: Partial drainage</span><br>
                        <span style="color: var(--accent-warning);">0.2-0.3: Moderate pore pressure</span><br>
                        <span style="color: var(--accent-danger);">0.3-0.5: High pore pressure</span>
                    </div>
                </div>
            </div>
            
            <div id="combinedControls" style="display: none;">
                <div class="input-sublabel" style="margin-bottom: 0.5rem; color: var(--text-dim);">
                    Combined mode: Water table defines phreatic surface; Ru applies additional pore pressure below it
                </div>
            </div>

            <!-- MODEL PARAMETERS -->
            <div class="section-header">
                ‚öôÔ∏è Search Constraints
                <button class="help-btn" onclick="showGeometryHelp()" title="Show geometry diagram">?</button>
            </div>
            
            <!-- Failure Mode Presets -->
            <div class="input-group">
                <label class="input-label">Failure Mode Preset</label>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="applyPreset('bench')" title="Single bench failure">Bench</button>
                    <button class="preset-btn active" onclick="applyPreset('interramp')" title="Inter-ramp failure">Inter-Ramp</button>
                    <button class="preset-btn" onclick="applyPreset('overall')" title="Overall slope failure">Overall</button>
                    <button class="preset-btn" onclick="applyPreset('custom')" title="Custom constraints">Custom</button>
                </div>
            </div>
            
            <!-- Depth and Radius Constraints -->
            <div class="constraint-group" id="constraintControls">
                <div class="input-row">
                    <div class="input-group">
                        <label class="input-label">
                            Max Depth (% of H)
                            <span class="range-value" id="maxDepthValue">50%</span>
                        </label>
                        <input type="range" id="maxDepthPercent" value="50" min="10" max="150" step="5" 
                               oninput="updateConstraintDisplay()">
                    </div>
                    <div class="input-group">
                        <label class="input-label">
                            Max Depth: <span id="maxDepthFt">100</span> ft
                        </label>
                    </div>
                </div>
                
                <div class="input-row">
                    <div class="input-group">
                        <label class="input-label">Min Radius (ft)</label>
                        <input type="number" id="minRadius" value="20" min="5" max="500" step="5" 
                               onchange="updateConstraintDisplay()">
                    </div>
                    <div class="input-group">
                        <label class="input-label">Max Radius (ft)</label>
                        <input type="number" id="maxRadius" value="400" min="20" max="2000" step="10" 
                               onchange="updateConstraintDisplay()">
                    </div>
                </div>
                
                <div class="constraint-summary" id="constraintSummary">
                    Depth ‚â§ 100 ft | Radius: 20 - 400 ft
                </div>
            </div>
            
            <div class="input-sublabel" style="margin: 0.75rem 0; color: var(--accent-blue);">
                üí° Drag limit handles on the visualization to adjust search zones
            </div>

            <div class="input-group">
                <label class="input-label">Entry Search Zone (ft from toe, + = upslope)</label>
                <div class="limit-range-display">
                    <span id="toeMinValue">-30</span>
                    <div class="limit-bar">
                        <div class="limit-bar-fill" id="toeBarFill"></div>
                        <div class="limit-bar-zero"></div>
                    </div>
                    <span id="toeMaxValue">+30</span>
                </div>
                <div class="input-row" style="margin-top: 0.5rem;">
                    <input type="number" id="toeMin" value="-30" min="-300" max="500" step="5" onchange="updateLimitDisplay('toe')">
                    <input type="number" id="toeMax" value="30" min="-300" max="500" step="5" onchange="updateLimitDisplay('toe')">
                </div>
            </div>

            <div class="input-group">
                <label class="input-label">Exit Search Zone (ft from crest, - = downslope)</label>
                <div class="limit-range-display">
                    <span id="crestMinValue">-50</span>
                    <div class="limit-bar">
                        <div class="limit-bar-fill" id="crestBarFill"></div>
                        <div class="limit-bar-zero"></div>
                    </div>
                    <span id="crestMaxValue">+50</span>
                </div>
                <div class="input-row" style="margin-top: 0.5rem;">
                    <input type="number" id="crestMin" value="-50" min="-500" max="300" step="5" onchange="updateLimitDisplay('crest')">
                    <input type="number" id="crestMax" value="50" min="-500" max="300" step="5" onchange="updateLimitDisplay('crest')">
                </div>
            </div>

            <div class="input-row">
                <div class="input-group">
                    <label class="input-label">Slices <span class="range-value" id="numSlicesValue">25</span></label>
                    <input type="range" id="numSlices" value="25" min="10" max="50" step="5">
                </div>
                <div class="input-group">
                    <label class="input-label">Grid Density <span class="range-value" id="gridDensityValue">12</span></label>
                    <input type="range" id="gridDensity" value="12" min="5" max="25" step="1">
                </div>
            </div>

            <button class="button" onclick="runAnalysis()">Execute Analysis</button>
            
            <!-- Import/Export Section -->
            <div class="io-section">
                <div class="io-buttons">
                    <button class="button button-secondary" onclick="exportCSV()" title="Save parameters to CSV">
                        üì• Export CSV
                    </button>
                    <button class="button button-secondary" onclick="document.getElementById('csvFileInput').click()" title="Load parameters from CSV">
                        üì§ Import CSV
                    </button>
                    <input type="file" id="csvFileInput" accept=".csv" style="display:none" onchange="importCSV(event)">
                </div>
                <div class="io-buttons" style="margin-top: 0.5rem;">
                    <button class="button button-secondary" onclick="exportPDF()" title="Generate PDF report" id="pdfExportBtn" disabled>
                        üìÑ Export PDF Report
                    </button>
                </div>
                <div class="io-hint">Run analysis to enable PDF export</div>
            </div>
        </div>

        <!-- Geometry Help Modal -->
        <div class="modal-overlay" id="geometryHelpModal" onclick="hideGeometryHelp(event)">
            <div class="modal-content" onclick="event.stopPropagation()">
                <div class="modal-header">
                    <span>Search Constraint Geometry</span>
                    <button class="modal-close" onclick="hideGeometryHelp()">&times;</button>
                </div>
                <div class="modal-body">
                    <canvas id="helpCanvas" width="600" height="450"></canvas>
                    <div class="help-legend">
                        <div class="help-item">
                            <strong>Max Depth:</strong> Maximum vertical distance from slope surface to failure arc. 
                            Shallower depths find bench-scale or surficial failures.
                        </div>
                        <div class="help-item">
                            <strong>Min/Max Radius:</strong> Circle radius bounds. Smaller radii = tighter, shallower arcs. 
                            Larger radii = deeper, more sweeping failures.
                        </div>
                        <div class="help-item">
                            <strong>Entry Zone:</strong> Where the failure surface enters the slope (toe area). 
                            Positive values move upslope from toe.
                        </div>
                        <div class="help-item">
                            <strong>Exit Zone:</strong> Where the failure surface exits (crest area). 
                            Negative values move downslope from crest.
                        </div>
                    </div>
                    <div class="preset-descriptions">
                        <div class="preset-desc">
                            <span class="preset-name">Bench:</span> Shallow, single-bench failures. Max depth ~25% H, small radius range.
                        </div>
                        <div class="preset-desc">
                            <span class="preset-name">Inter-Ramp:</span> Mid-depth failures spanning multiple benches. Max depth ~50% H.
                        </div>
                        <div class="preset-desc">
                            <span class="preset-name">Overall:</span> Deep-seated failures through entire slope. Max depth ~100% H or more.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div>
            <!-- VISUALIZATION - MOVED TO TOP -->
            <div class="canvas-container">
                <div class="panel-header">Failure Surface Visualization</div>
                <canvas id="slopeCanvas" width="1100" height="600"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #ff9e64;"></div>
                        Critical Surface
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: transparent; border: 2px dashed #9ece6a;"></div>
                        Overall Slope Angle (OSA)
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: transparent; border: 2px dashed #bb9af7;"></div>
                        Inter-Ramp Angle (IRA)
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: rgba(247, 118, 142, 0.15);"></div>
                        Search Zone
                    </div>
                </div>
            </div>

            <!-- RESULTS - NOW BELOW VISUALIZATION -->
            <div class="results-panel" id="resultsPanel" style="display: none;">
                <div class="panel-header">Analysis Results</div>
                <div id="warningBanner"></div>
                
                <!-- Primary Result: FoS -->
                <div class="result-primary">
                    <div class="result-card fos-card">
                        <div class="result-label">Factor of Safety</div>
                        <div class="result-value" id="minFos">--</div>
                        <div class="result-sublabel" id="fosStatus">--</div>
                    </div>
                </div>
                
                <!-- Critical Surface Geometry -->
                <div class="result-section">
                    <div class="result-section-header">Critical Surface Geometry</div>
                    <div class="result-grid-compact">
                        <div class="result-item">
                            <span class="result-item-label">Entry Point</span>
                            <span class="result-item-value" id="entryPoint">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-item-label">Exit Point</span>
                            <span class="result-item-value" id="exitPoint">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-item-label">Failure Depth</span>
                            <span class="result-item-value" id="criticalDepth">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-item-label">Arc Length</span>
                            <span class="result-item-value" id="surfaceLength">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-item-label">Circle Radius</span>
                            <span class="result-item-value" id="circleRadius">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-item-label">Circle Center</span>
                            <span class="result-item-value" id="circleCenter">--</span>
                        </div>
                    </div>
                </div>
                
                <!-- Mass Estimation -->
                <div class="result-section">
                    <div class="result-section-header">Failure Mass Estimation</div>
                    <div class="result-grid-compact">
                        <div class="result-item">
                            <span class="result-item-label">Cross-Section Area</span>
                            <span class="result-item-value" id="crossSectionArea">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-item-label">Slide Weight (2D)</span>
                            <span class="result-item-value" id="slideWeight">--</span>
                        </div>
                    </div>
                    <div class="volume-input-row">
                        <div class="result-item" style="flex: 1;">
                            <span class="result-item-label">Failure Width (ft)</span>
                            <input type="number" id="failureWidth" value="100" min="1" max="10000" step="1" onchange="updateVolumeEstimate()" oninput="updateVolumeEstimate()">
                        </div>
                        <div class="result-item" style="flex: 1;">
                            <span class="result-item-label">Est. Volume</span>
                            <span class="result-item-value volume-highlight" id="totalVolume">--</span>
                        </div>
                        <div class="result-item" style="flex: 1;">
                            <span class="result-item-label">Est. Tonnage</span>
                            <span class="result-item-value volume-highlight" id="totalTonnage">--</span>
                        </div>
                    </div>
                </div>
                
                <!-- Force Summary -->
                <div class="result-section">
                    <div class="result-section-header">Force Summary</div>
                    <div class="result-grid-compact">
                        <div class="result-item">
                            <span class="result-item-label">Œ£ Resisting</span>
                            <span class="result-item-value" id="sumResisting">--</span>
                        </div>
                        <div class="result-item">
                            <span class="result-item-label">Œ£ Driving</span>
                            <span class="result-item-value" id="sumDriving">--</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- CALCULATION DETAILS -->
            <div class="calc-panel" id="calcPanel" style="display: none;">
                <div class="panel-header">Modified Bishop's Method - Calculation Details</div>
                
                <div class="equation-box">
                    <div class="equation-main">
                        FoS = Œ£ [ (c'¬∑b + (W - u¬∑b)¬∑tan œÜ') / m<sub>Œ±</sub> ] / Œ£ [ W¬∑sin Œ± ]
                    </div>
                    <div style="text-align: center; color: var(--text-dim); font-size: 0.8rem;">
                        m<sub>Œ±</sub> = cos Œ± + (sin Œ± ¬∑ tan œÜ') / FoS
                    </div>
                    <div class="equation-terms" id="inputSummary"></div>
                </div>

                <button class="toggle-details" onclick="toggleSliceTable()">‚ñº Show Slice Calculations</button>

                <div class="collapsible" id="sliceDetails">
                    <div class="slice-table-container">
                        <table class="slice-table" id="sliceTable">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>x</th>
                                    <th>b</th>
                                    <th>h</th>
                                    <th>W</th>
                                    <th>Œ±¬∞</th>
                                    <th>u</th>
                                    <th>m<sub>Œ±</sub></th>
                                    <th>Resist</th>
                                    <th>Drive</th>
                                </tr>
                            </thead>
                            <tbody id="sliceTableBody"></tbody>
                        </table>
                    </div>
                </div>

                <div class="summary-calc" id="summaryCalc"></div>
            </div>

            <!-- SENSITIVITY ANALYSIS -->
            <div class="sensitivity-panel" id="sensitivityPanel">
                <div class="panel-header">üìä Sensitivity Analysis</div>
                
                <div class="sensitivity-controls">
                    <div class="input-group">
                        <label class="input-label">Parameter to Vary</label>
                        <select id="sensitivityParam" onchange="updateSensitivityRange()">
                            <optgroup label="Material Properties">
                                <option value="cohesion">Cohesion, c' (psf)</option>
                                <option value="frictionAngle">Friction Angle, œÜ' (degrees)</option>
                                <option value="unitWeight">Unit Weight, Œ≥ (pcf)</option>
                            </optgroup>
                            <optgroup label="Geometry">
                                <option value="slopeHeight">Slope Height, H (ft)</option>
                                <option value="slopeAngle">Slope Angle, Œ≤ (degrees)</option>
                            </optgroup>
                            <optgroup label="Pore Pressure / Dewatering">
                                <option value="waterTable">Water Table Depth (ft)</option>
                                <option value="ruCoeff">Ru Coefficient (Pore Pressure Ratio)</option>
                            </optgroup>
                        </select>
                    </div>
                    
                    <div class="input-row">
                        <div class="input-group">
                            <label class="input-label">Min Value</label>
                            <input type="number" id="sensitivityMin" value="0" step="any">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Max Value</label>
                            <input type="number" id="sensitivityMax" value="1000" step="any">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Steps</label>
                            <input type="number" id="sensitivitySteps" value="10" min="3" max="25" step="1">
                        </div>
                    </div>
                    
                    <button class="button button-secondary" onclick="runSensitivityAnalysis()">
                        Run Sensitivity Analysis
                    </button>
                </div>
                
                <div id="sensitivityResults" style="display: none;">
                    <div class="sensitivity-chart-container">
                        <canvas id="sensitivityChart" width="800" height="350"></canvas>
                    </div>
                    
                    <div class="sensitivity-table-container">
                        <table class="sensitivity-table" id="sensitivityTable">
                            <thead>
                                <tr>
                                    <th id="sensitivityParamHeader">Parameter</th>
                                    <th>FoS</th>
                                    <th>Change</th>
                                    <th>Status</th>
                                </tr>
                            </thead>
                            <tbody id="sensitivityTableBody"></tbody>
                        </table>
                    </div>
                    
                    <div class="sensitivity-summary" id="sensitivitySummary"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Material database
        const materialDatabase = {
            hard_rock: { cohesion: 10000, friction: 40, weight: 165 },
            weathered_rock: { cohesion: 2000, friction: 35, weight: 150 },
            fractured_rock: { cohesion: 1000, friction: 32, weight: 155 },
            shale: { cohesion: 800, friction: 25, weight: 140 },
            dense_sand: { cohesion: 0, friction: 38, weight: 130 },
            loose_sand: { cohesion: 0, friction: 28, weight: 110 },
            stiff_clay: { cohesion: 1500, friction: 25, weight: 125 },
            soft_clay: { cohesion: 300, friction: 15, weight: 115 },
            waste_rock: { cohesion: 200, friction: 35, weight: 130 },
            heap_leach: { cohesion: 300, friction: 32, weight: 115 }
        };

        // Segment storage
        let segments = [];
        let segmentIdCounter = 0;
        let advancedMode = false;
        let lastAnalysisResult = null;
        
        // Interactive drag state for limit lines
        let dragState = {
            active: false,
            line: null, // 'toeLeft', 'toeRight', 'crestLeft', 'crestRight'
            startX: 0,
            startValue: 0
        };
        let vizState = null; // Stores visualization coordinate transforms

        // Event listeners
        document.getElementById('slopeAngle').addEventListener('input', function() {
            document.getElementById('slopeAngleValue').textContent = this.value + '¬∞';
        });
        document.getElementById('frictionAngle').addEventListener('input', function() {
            document.getElementById('frictionAngleValue').textContent = this.value + '¬∞';
        });
        document.getElementById('waterTable').addEventListener('input', function() {
            document.getElementById('waterTableValue').textContent = this.value + ' ft';
        });
        document.getElementById('numSlices').addEventListener('input', function() {
            document.getElementById('numSlicesValue').textContent = this.value;
        });
        document.getElementById('gridDensity').addEventListener('input', function() {
            document.getElementById('gridDensityValue').textContent = this.value;
        });
        document.getElementById('slopeHeight').addEventListener('input', function() {
            updateHeightIndicator();
            updateConstraintDisplay();
        });

        // Pore pressure model UI handler
        function updatePorePressureUI() {
            const model = document.getElementById('porePressureModel').value;
            const wtControls = document.getElementById('waterTableControls');
            const ruControls = document.getElementById('ruControls');
            const combinedControls = document.getElementById('combinedControls');
            
            wtControls.style.display = 'none';
            ruControls.style.display = 'none';
            combinedControls.style.display = 'none';
            
            if (model === 'watertable') {
                wtControls.style.display = 'block';
            } else if (model === 'ru') {
                ruControls.style.display = 'block';
            } else if (model === 'combined') {
                wtControls.style.display = 'block';
                ruControls.style.display = 'block';
                combinedControls.style.display = 'block';
            }
        }

        // Get pore pressure parameters
        function getPorePressureParams() {
            const model = document.getElementById('porePressureModel').value;
            return {
                model: model,
                waterTableDepth: parseFloat(document.getElementById('waterTable').value) || 50,
                ru: parseFloat(document.getElementById('ruCoeff').value) || 0
            };
        }

        // Constraint and preset functions
        function getConstraints() {
            const H = parseFloat(document.getElementById('slopeHeight').value) || 200;
            const maxDepthPercent = parseFloat(document.getElementById('maxDepthPercent').value) || 50;
            return {
                maxDepth: H * maxDepthPercent / 100,
                maxDepthPercent: maxDepthPercent,
                minRadius: parseFloat(document.getElementById('minRadius').value) || 20,
                maxRadius: parseFloat(document.getElementById('maxRadius').value) || 400
            };
        }

        function updateConstraintDisplay() {
            const H = parseFloat(document.getElementById('slopeHeight').value) || 200;
            const maxDepthPercent = parseFloat(document.getElementById('maxDepthPercent').value) || 50;
            const maxDepthFt = H * maxDepthPercent / 100;
            const minR = parseFloat(document.getElementById('minRadius').value) || 20;
            const maxR = parseFloat(document.getElementById('maxRadius').value) || 400;
            
            document.getElementById('maxDepthValue').textContent = maxDepthPercent + '%';
            document.getElementById('maxDepthFt').textContent = maxDepthFt.toFixed(0);
            document.getElementById('constraintSummary').textContent = 
                `Depth ‚â§ ${maxDepthFt.toFixed(0)} ft | Radius: ${minR} - ${maxR} ft`;
        }

        function applyPreset(preset) {
            // Update active button
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            
            const H = parseFloat(document.getElementById('slopeHeight').value) || 200;
            
            switch(preset) {
                case 'bench':
                    // Shallow, single-bench failures
                    document.getElementById('maxDepthPercent').value = 25;
                    document.getElementById('minRadius').value = 15;
                    document.getElementById('maxRadius').value = Math.max(100, H * 0.5);
                    document.getElementById('toeMin').value = -20;
                    document.getElementById('toeMax').value = 50;
                    document.getElementById('crestMin').value = -80;
                    document.getElementById('crestMax').value = 20;
                    break;
                    
                case 'interramp':
                    // Inter-ramp failures (default)
                    document.getElementById('maxDepthPercent').value = 50;
                    document.getElementById('minRadius').value = 20;
                    document.getElementById('maxRadius').value = Math.max(400, H * 1.5);
                    document.getElementById('toeMin').value = -30;
                    document.getElementById('toeMax').value = 30;
                    document.getElementById('crestMin').value = -50;
                    document.getElementById('crestMax').value = 50;
                    break;
                    
                case 'overall':
                    // Deep-seated overall slope failures
                    document.getElementById('maxDepthPercent').value = 100;
                    document.getElementById('minRadius').value = 50;
                    document.getElementById('maxRadius').value = Math.max(800, H * 3);
                    document.getElementById('toeMin').value = -50;
                    document.getElementById('toeMax').value = 20;
                    document.getElementById('crestMin').value = -30;
                    document.getElementById('crestMax').value = 80;
                    break;
                    
                case 'custom':
                    // Don't change anything, just enable editing
                    break;
            }
            
            updateConstraintDisplay();
            updateLimitDisplay('toe');
            updateLimitDisplay('crest');
        }

        // Help modal functions
        function showGeometryHelp() {
            document.getElementById('geometryHelpModal').classList.add('show');
            drawHelpDiagram();
        }

        function hideGeometryHelp(event) {
            if (!event || event.target === document.getElementById('geometryHelpModal')) {
                document.getElementById('geometryHelpModal').classList.remove('show');
            }
        }

        function drawHelpDiagram() {
            const canvas = document.getElementById('helpCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            const margin = 40;
            const w = canvas.width - 2 * margin;
            const h = canvas.height - 2 * margin - 50;
            
            // Slope dimensions
            const slopeH = h * 0.7;
            const slopeW = w * 0.6;
            const toeX = margin + w * 0.15;
            const toeY = margin + h;
            const crestX = toeX + slopeW;
            const crestY = toeY - slopeH;
            
            // Background
            ctx.fillStyle = '#1a1b26';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Ground line
            ctx.strokeStyle = '#565f89';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(margin, toeY);
            ctx.lineTo(canvas.width - margin, toeY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Slope profile
            ctx.fillStyle = 'rgba(192, 202, 245, 0.1)';
            ctx.strokeStyle = '#c0caf5';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(margin, toeY);
            ctx.lineTo(toeX, toeY);
            ctx.lineTo(crestX, crestY);
            ctx.lineTo(canvas.width - margin, crestY);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(toeX, toeY);
            ctx.lineTo(crestX, crestY);
            ctx.lineTo(crestX, toeY);
            ctx.closePath();
            ctx.fill();
            
            // Example circle (critical surface)
            const circleR = slopeH * 0.8;
            const circleCX = (toeX + crestX) / 2 + 20;
            const circleCY = crestY - circleR * 0.3;
            
            // Find entry/exit points (approximate)
            const entryX = toeX + 15;
            const exitX = crestX - 20;
            const entryAngle = Math.acos((entryX - circleCX) / circleR);
            const exitAngle = Math.acos((exitX - circleCX) / circleR);
            
            // Draw failure arc
            ctx.strokeStyle = '#ff9e64';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(circleCX, circleCY, circleR, entryAngle, exitAngle, false);
            ctx.stroke();
            
            // Fill failure mass
            ctx.fillStyle = 'rgba(255, 158, 100, 0.2)';
            ctx.beginPath();
            ctx.moveTo(entryX, toeY - (entryX - toeX) * (slopeH / slopeW));
            ctx.arc(circleCX, circleCY, circleR, entryAngle, exitAngle, false);
            ctx.lineTo(exitX, crestY + (crestX - exitX) * (slopeH / slopeW));
            ctx.closePath();
            ctx.fill();
            
            // Max depth line
            const maxDepthY = circleCY + circleR;
            const surfaceAtDepthX = (toeX + crestX) / 2;
            const surfaceAtDepthY = toeY - (surfaceAtDepthX - toeX) * (slopeH / slopeW);
            const depthValue = maxDepthY - surfaceAtDepthY;
            
            ctx.strokeStyle = '#f7768e';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(surfaceAtDepthX, surfaceAtDepthY);
            ctx.lineTo(surfaceAtDepthX, maxDepthY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Max depth label
            ctx.fillStyle = '#f7768e';
            ctx.font = 'bold 12px JetBrains Mono';
            ctx.textAlign = 'left';
            ctx.fillText('Max Depth', surfaceAtDepthX + 10, (surfaceAtDepthY + maxDepthY) / 2);
            
            // Radius line
            ctx.strokeStyle = '#7aa2f7';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(circleCX, circleCY);
            ctx.lineTo(circleCX + circleR * Math.cos(Math.PI * 0.7), circleCY + circleR * Math.sin(Math.PI * 0.7));
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Radius label
            ctx.fillStyle = '#7aa2f7';
            ctx.font = 'bold 11px JetBrains Mono';
            ctx.fillText('R', circleCX - 30, circleCY + circleR * 0.4);
            
            // Circle center
            ctx.fillStyle = '#7aa2f7';
            ctx.beginPath();
            ctx.arc(circleCX, circleCY, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillText('Center', circleCX + 10, circleCY - 5);
            
            // Entry zone
            ctx.fillStyle = 'rgba(247, 118, 142, 0.15)';
            ctx.fillRect(toeX - 30, crestY - 20, 80, slopeH + 40);
            ctx.strokeStyle = '#f7768e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toeX - 30, crestY - 20);
            ctx.lineTo(toeX - 30, toeY + 20);
            ctx.moveTo(toeX + 50, crestY - 20);
            ctx.lineTo(toeX + 50, toeY + 20);
            ctx.stroke();
            
            // Exit zone
            ctx.fillStyle = 'rgba(247, 118, 142, 0.15)';
            ctx.fillRect(crestX - 60, crestY - 20, 100, slopeH + 40);
            ctx.beginPath();
            ctx.moveTo(crestX - 60, crestY - 20);
            ctx.lineTo(crestX - 60, toeY + 20);
            ctx.moveTo(crestX + 40, crestY - 20);
            ctx.lineTo(crestX + 40, toeY + 20);
            ctx.stroke();
            
            // Zone labels
            ctx.fillStyle = '#f7768e';
            ctx.font = '11px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText('Entry', toeX + 10, toeY + 35);
            ctx.fillText('Zone', toeX + 10, toeY + 48);
            ctx.fillText('Exit', crestX - 10, crestY - 30);
            ctx.fillText('Zone', crestX - 10, crestY - 17);
            
            // Toe and Crest labels
            ctx.fillStyle = '#9ece6a';
            ctx.font = 'bold 12px JetBrains Mono';
            ctx.fillText('TOE', toeX, toeY + 70);
            ctx.fillText('CREST', crestX, crestY - 50);
            
            // Height label
            ctx.fillStyle = '#a9b1d6';
            ctx.font = 'bold 12px JetBrains Mono';
            ctx.textAlign = 'right';
            ctx.fillText('H', toeX - 15, (toeY + crestY) / 2);
            
            // Height dimension line
            ctx.strokeStyle = '#a9b1d6';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(toeX - 10, toeY);
            ctx.lineTo(toeX - 10, crestY);
            ctx.stroke();
            
            // Legend
            ctx.textAlign = 'left';
            ctx.font = '10px JetBrains Mono';
            
            const legendY = canvas.height - 25;
            
            ctx.fillStyle = '#ff9e64';
            ctx.fillRect(margin, legendY, 12, 12);
            ctx.fillStyle = '#a9b1d6';
            ctx.fillText('Critical Surface', margin + 18, legendY + 10);
            
            ctx.fillStyle = '#f7768e';
            ctx.fillRect(margin + 130, legendY, 12, 12);
            ctx.fillStyle = '#a9b1d6';
            ctx.fillText('Max Depth', margin + 148, legendY + 10);
            
            ctx.fillStyle = '#7aa2f7';
            ctx.fillRect(margin + 240, legendY, 12, 12);
            ctx.fillStyle = '#a9b1d6';
            ctx.fillText('Radius', margin + 258, legendY + 10);
            
            ctx.fillStyle = 'rgba(247, 118, 142, 0.3)';
            ctx.fillRect(margin + 330, legendY, 12, 12);
            ctx.fillStyle = '#a9b1d6';
            ctx.fillText('Search Zones', margin + 348, legendY + 10);
        }

        // Initialize constraint display on load
        document.addEventListener('DOMContentLoaded', function() {
            updateConstraintDisplay();
        });

        // Update limit display bars and values
        function updateLimitDisplay(zone) {
            const minVal = parseFloat(document.getElementById(zone + 'Min').value) || 0;
            const maxVal = parseFloat(document.getElementById(zone + 'Max').value) || 0;
            
            document.getElementById(zone + 'MinValue').textContent = (minVal >= 0 ? '+' : '') + minVal;
            document.getElementById(zone + 'MaxValue').textContent = (maxVal >= 0 ? '+' : '') + maxVal;
            
            // Update bar fill - dynamically scale based on actual values
            const absMax = Math.max(Math.abs(minVal), Math.abs(maxVal), 50);
            const displayRange = absMax * 2;
            const barFill = document.getElementById(zone + 'BarFill');
            const leftPercent = ((minVal + absMax) / displayRange) * 100;
            const rightPercent = ((maxVal + absMax) / displayRange) * 100;
            barFill.style.left = Math.max(0, Math.min(100, leftPercent)) + '%';
            barFill.style.width = Math.max(0, Math.min(100 - leftPercent, rightPercent - leftPercent)) + '%';
            
            // Update the zero line position
            const zeroLine = document.getElementById(zone + 'BarFill').parentElement.querySelector('.limit-bar-zero');
            if (zeroLine) {
                const zeroPercent = (absMax / displayRange) * 100;
                zeroLine.style.left = zeroPercent + '%';
            }
        }

        // Get current limit values
        function getLimits() {
            return {
                toeMin: parseFloat(document.getElementById('toeMin').value) || -30,
                toeMax: parseFloat(document.getElementById('toeMax').value) || 30,
                crestMin: parseFloat(document.getElementById('crestMin').value) || -50,
                crestMax: parseFloat(document.getElementById('crestMax').value) || 50
            };
        }

        // Set limit values and update display
        function setLimit(id, value) {
            const input = document.getElementById(id);
            if (input) {
                input.value = Math.round(value);
                const zone = id.replace('Min', '').replace('Max', '');
                updateLimitDisplay(zone);
            }
        }

        function updateMaterialProperties() {
            const type = document.getElementById('materialType').value;
            if (type !== 'custom' && materialDatabase[type]) {
                const mat = materialDatabase[type];
                document.getElementById('cohesion').value = mat.cohesion;
                document.getElementById('frictionAngle').value = mat.friction;
                document.getElementById('frictionAngleValue').textContent = mat.friction + '¬∞';
                document.getElementById('unitWeight').value = mat.weight;
            }
        }

        function toggleAdvanced() {
            advancedMode = !advancedMode;
            const toggle = document.getElementById('advancedToggle');
            const content = document.getElementById('advancedContent');
            const simpleGeom = document.getElementById('simpleGeometry');
            const simpleMat = document.getElementById('simpleMaterial');
            
            toggle.classList.toggle('active', advancedMode);
            content.classList.toggle('show', advancedMode);
            simpleGeom.style.display = advancedMode ? 'none' : 'block';
            simpleMat.style.display = advancedMode ? 'none' : 'block';
            
            if (advancedMode && segments.length === 0) {
                addSegment();
            }
            updateHeightIndicator();
        }

        function updateHeightIndicator() {
            const totalH = parseFloat(document.getElementById('slopeHeight').value) || 200;
            const usedH = segments.reduce((sum, seg) => sum + ((seg.benchHeight || 0) * (seg.numBenches || 1)), 0);
            const remaining = totalH - usedH;
            
            document.getElementById('usedHeight').textContent = usedH.toFixed(0);
            document.getElementById('remainingHeight').textContent = remaining.toFixed(0);
            
            const indicator = document.getElementById('heightIndicator');
            indicator.classList.toggle('over', remaining < 0);
            
            // Update status message
            const status = document.getElementById('heightStatus');
            if (status) {
                if (Math.abs(remaining) < 0.5) {
                    status.textContent = '‚úì Exact fit';
                    status.style.color = 'var(--accent-safe)';
                } else if (remaining > 0) {
                    status.textContent = `Will extrapolate ${remaining.toFixed(0)} ft`;
                    status.style.color = 'var(--accent-blue)';
                } else {
                    status.textContent = `Will trim ${Math.abs(remaining).toFixed(0)} ft`;
                    status.style.color = 'var(--accent-warning)';
                }
            }
        }

        function addSegment() {
            const id = segmentIdCounter++;
            const totalH = parseFloat(document.getElementById('slopeHeight').value) || 200;
            const usedH = segments.reduce((sum, seg) => sum + ((seg.benchHeight || 0) * (seg.numBenches || 1)), 0);
            const remainingH = totalH - usedH;
            
            // Default to reasonable bench height and calculate benches to fill remaining
            const defaultBenchHeight = 40;
            const defaultNumBenches = Math.max(1, Math.floor(remainingH / defaultBenchHeight));
            
            const segment = {
                id: id,
                benchHeight: defaultBenchHeight,
                numBenches: defaultNumBenches,
                benchFaceAngle: 65,
                catchBenchWidth: 25,
                stepoutType: 'none',
                stepoutWidth: 0,
                materialType: 'custom',
                cohesion: 300,
                frictionAngle: 30,
                unitWeight: 125
            };
            
            segments.push(segment);
            renderSegments();
            updateHeightIndicator();
        }

        function removeSegment(id) {
            segments = segments.filter(s => s.id !== id);
            renderSegments();
            updateHeightIndicator();
        }

        function updateSegment(id, field, value) {
            const seg = segments.find(s => s.id === id);
            if (seg) {
                seg[field] = parseFloat(value) || value;
                if (field === 'materialType' && materialDatabase[value]) {
                    const mat = materialDatabase[value];
                    seg.cohesion = mat.cohesion;
                    seg.frictionAngle = mat.friction;
                    seg.unitWeight = mat.weight;
                    renderSegments();
                }
                updateHeightIndicator();
            }
        }

        function renderSegments() {
            const container = document.getElementById('segmentsContainer');
            container.innerHTML = '';
            
            let cumulativeHeight = 0;
            
            segments.forEach((seg, index) => {
                const segmentTotalHeight = (seg.benchHeight || 40) * (seg.numBenches || 1);
                const ira = calculateIRA(seg.benchHeight, seg.benchFaceAngle, seg.catchBenchWidth);
                const startElev = cumulativeHeight;
                const endElev = cumulativeHeight + segmentTotalHeight;
                cumulativeHeight = endElev;
                
                const html = `
                <div class="segment-card" data-id="${seg.id}">
                    <div class="segment-header">
                        <div>
                            <span class="segment-title">Segment ${index + 1}</span>
                            <span class="segment-info">IRA: ${ira.toFixed(1)}¬∞ | ${segmentTotalHeight.toFixed(0)} ft total</span>
                        </div>
                        ${segments.length > 1 ? `<button class="segment-delete" onclick="removeSegment(${seg.id})">‚úï</button>` : ''}
                    </div>
                    
                    <div class="segment-elevation-bar">
                        <span>Elev ${startElev.toFixed(0)}' ‚Üí ${endElev.toFixed(0)}'</span>
                    </div>
                    
                    <div class="input-row" style="margin-bottom: 0.75rem;">
                        <div class="input-group">
                            <label class="input-label">Bench Height (ft)</label>
                            <input type="number" value="${seg.benchHeight}" min="10" max="200" step="5"
                                   onchange="updateSegment(${seg.id}, 'benchHeight', this.value); renderSegments();">
                        </div>
                        <div class="input-group">
                            <label class="input-label"># of Benches</label>
                            <input type="number" value="${seg.numBenches || 1}" min="1" max="50" step="1"
                                   onchange="updateSegment(${seg.id}, 'numBenches', this.value); renderSegments();">
                        </div>
                    </div>
                    
                    <div class="input-row-3">
                        <div class="input-group">
                            <label class="input-label">Face Angle (¬∞)</label>
                            <input type="number" value="${seg.benchFaceAngle}" min="30" max="90" step="1"
                                   onchange="updateSegment(${seg.id}, 'benchFaceAngle', this.value); renderSegments();">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Catch Width (ft)</label>
                            <input type="number" value="${seg.catchBenchWidth}" min="0" max="100" step="1"
                                   onchange="updateSegment(${seg.id}, 'catchBenchWidth', this.value); renderSegments();">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Segment Height</label>
                            <div style="padding: 0.6rem; background: var(--bg-primary); border-radius: 3px; font-family: 'JetBrains Mono', monospace; font-size: 0.85rem; color: var(--accent-primary);">
                                ${segmentTotalHeight.toFixed(0)} ft
                            </div>
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <label class="input-label">Material</label>
                        <select onchange="updateSegment(${seg.id}, 'materialType', this.value)">
                            <option value="custom" ${seg.materialType === 'custom' ? 'selected' : ''}>Custom</option>
                            <option value="hard_rock" ${seg.materialType === 'hard_rock' ? 'selected' : ''}>Hard Rock</option>
                            <option value="weathered_rock" ${seg.materialType === 'weathered_rock' ? 'selected' : ''}>Weathered Rock</option>
                            <option value="fractured_rock" ${seg.materialType === 'fractured_rock' ? 'selected' : ''}>Fractured Rock</option>
                            <option value="waste_rock" ${seg.materialType === 'waste_rock' ? 'selected' : ''}>Waste Rock</option>
                        </select>
                    </div>
                    
                    <div class="input-row-3">
                        <div class="input-group">
                            <label class="input-label">c' (psf)</label>
                            <input type="number" value="${seg.cohesion}" min="0" max="10000" step="50"
                                   onchange="updateSegment(${seg.id}, 'cohesion', this.value)">
                        </div>
                        <div class="input-group">
                            <label class="input-label">œÜ' (¬∞)</label>
                            <input type="number" value="${seg.frictionAngle}" min="0" max="50" step="1"
                                   onchange="updateSegment(${seg.id}, 'frictionAngle', this.value)">
                        </div>
                        <div class="input-group">
                            <label class="input-label">Œ≥ (pcf)</label>
                            <input type="number" value="${seg.unitWeight}" min="90" max="180" step="1"
                                   onchange="updateSegment(${seg.id}, 'unitWeight', this.value)">
                        </div>
                    </div>
                    
                    <div class="stepout-section">
                        <label class="input-label" style="margin-bottom: 0.5rem;">Stepout Above This Segment</label>
                        <div class="stepout-type">
                            <input type="radio" name="stepout-${seg.id}" id="stepout-none-${seg.id}" value="none" 
                                   ${seg.stepoutType === 'none' ? 'checked' : ''} 
                                   onchange="updateSegment(${seg.id}, 'stepoutType', 'none'); renderSegments();">
                            <label for="stepout-none-${seg.id}">None</label>
                            
                            <input type="radio" name="stepout-${seg.id}" id="stepout-geotech-${seg.id}" value="geotech"
                                   ${seg.stepoutType === 'geotech' ? 'checked' : ''}
                                   onchange="updateSegment(${seg.id}, 'stepoutType', 'geotech'); renderSegments();">
                            <label for="stepout-geotech-${seg.id}">Geotech</label>
                            
                            <input type="radio" name="stepout-${seg.id}" id="stepout-ramp-${seg.id}" value="ramp"
                                   ${seg.stepoutType === 'ramp' ? 'checked' : ''}
                                   onchange="updateSegment(${seg.id}, 'stepoutType', 'ramp'); renderSegments();">
                            <label for="stepout-ramp-${seg.id}">Ramp</label>
                        </div>
                        ${seg.stepoutType !== 'none' ? `
                        <div class="input-group" style="margin-bottom: 0;">
                            <label class="input-label">Additional Width (ft)</label>
                            <input type="number" value="${seg.stepoutWidth}" min="0" max="200" step="5"
                                   onchange="updateSegment(${seg.id}, 'stepoutWidth', this.value)">
                        </div>
                        ` : ''}
                    </div>
                </div>
                `;
                
                container.innerHTML += html;
            });
            
            updateHeightIndicator();
        }

        function calculateIRA(benchHeight, faceAngle, catchWidth) {
            // IRA = atan(benchHeight / (benchHeight/tan(faceAngle) + catchWidth))
            const faceRun = benchHeight / Math.tan(faceAngle * Math.PI / 180);
            const totalRun = faceRun + catchWidth;
            return Math.atan(benchHeight / totalRun) * 180 / Math.PI;
        }

        /**
         * Build slope profile from segments
         * Returns array of {x, y} points defining the slope surface
         * Handles extrapolation if segments don't reach total height,
         * or cuts off if segments exceed total height
         */
        function buildSlopeProfile() {
            const totalH = parseFloat(document.getElementById('slopeHeight').value);
            
            if (!advancedMode || segments.length === 0) {
                // Simple slope
                const beta = parseFloat(document.getElementById('slopeAngle').value) * Math.PI / 180;
                const xCrest = totalH / Math.tan(beta);
                return {
                    points: [
                        { x: 0, y: 0 },
                        { x: xCrest, y: totalH }
                    ],
                    xCrest: xCrest,
                    totalHeight: totalH,
                    simple: true,
                    segmentBoundaries: []
                };
            }
            
            // Build from segments (bottom to top), drawing each individual bench
            const points = [{ x: 0, y: 0 }];
            const segmentBoundaries = []; // Track where each segment starts/ends
            let currentX = 0;
            let currentY = 0;
            let reachedTarget = false;
            
            for (let segIdx = 0; segIdx < segments.length && !reachedTarget; segIdx++) {
                const seg = segments[segIdx];
                const faceAngle = seg.benchFaceAngle * Math.PI / 180;
                const numBenches = seg.numBenches || 1;
                const segmentStartY = currentY;
                
                // Draw each bench in this segment
                for (let b = 0; b < numBenches && !reachedTarget; b++) {
                    const isLastBenchInSegment = (b === numBenches - 1);
                    const isLastSegment = (segIdx === segments.length - 1);
                    
                    // Check if this bench would exceed target height
                    const projectedY = currentY + seg.benchHeight;
                    
                    if (projectedY > totalH) {
                        // This bench would exceed target - extrapolate partial bench
                        const remainingHeight = totalH - currentY;
                        if (remainingHeight > 0.5) {
                            const partialFaceRun = remainingHeight / Math.tan(faceAngle);
                            currentX += partialFaceRun;
                            currentY = totalH;
                            points.push({ x: currentX, y: currentY });
                        }
                        reachedTarget = true;
                    } else {
                        // Full bench face
                        const faceRun = seg.benchHeight / Math.tan(faceAngle);
                        currentX += faceRun;
                        currentY += seg.benchHeight;
                        points.push({ x: currentX, y: currentY });
                        
                        // Add catch bench (horizontal) if not at target height
                        if (currentY < totalH && seg.catchBenchWidth > 0) {
                            currentX += seg.catchBenchWidth;
                            points.push({ x: currentX, y: currentY });
                        }
                        
                        // Check if we've reached target
                        if (Math.abs(currentY - totalH) < 0.5) {
                            reachedTarget = true;
                        }
                    }
                }
                
                // Record segment boundary
                segmentBoundaries.push({
                    segmentIndex: segIdx,
                    startY: segmentStartY,
                    endY: currentY,
                    material: {
                        c: seg.cohesion,
                        phi: seg.frictionAngle * Math.PI / 180,
                        gamma: seg.unitWeight
                    }
                });
                
                // Add stepout after segment (if not at target height)
                if (!reachedTarget && seg.stepoutType !== 'none' && seg.stepoutWidth > 0) {
                    currentX += seg.stepoutWidth;
                    points.push({ x: currentX, y: currentY });
                }
            }
            
            // If segments didn't reach target height, extrapolate using last segment's geometry
            if (currentY < totalH - 0.5 && segments.length > 0) {
                const lastSeg = segments[segments.length - 1];
                const faceAngle = lastSeg.benchFaceAngle * Math.PI / 180;
                const remainingHeight = totalH - currentY;
                
                // Calculate how many more full benches plus partial
                const fullBenchesNeeded = Math.floor(remainingHeight / lastSeg.benchHeight);
                const partialHeight = remainingHeight - (fullBenchesNeeded * lastSeg.benchHeight);
                
                // Add full benches
                for (let b = 0; b < fullBenchesNeeded; b++) {
                    const faceRun = lastSeg.benchHeight / Math.tan(faceAngle);
                    currentX += faceRun;
                    currentY += lastSeg.benchHeight;
                    points.push({ x: currentX, y: currentY });
                    
                    if (currentY < totalH && lastSeg.catchBenchWidth > 0) {
                        currentX += lastSeg.catchBenchWidth;
                        points.push({ x: currentX, y: currentY });
                    }
                }
                
                // Add partial bench if needed
                if (partialHeight > 0.5) {
                    const partialFaceRun = partialHeight / Math.tan(faceAngle);
                    currentX += partialFaceRun;
                    currentY += partialHeight;
                    points.push({ x: currentX, y: currentY });
                }
                
                // Update last segment boundary
                if (segmentBoundaries.length > 0) {
                    segmentBoundaries[segmentBoundaries.length - 1].endY = currentY;
                }
            }
            
            return {
                points: points,
                xCrest: currentX,
                totalHeight: currentY,
                simple: false,
                segmentBoundaries: segmentBoundaries
            };
        }

        /**
         * Get surface Y at any X coordinate from profile
         */
        function getSurfaceY(x, profile) {
            const points = profile.points;
            
            if (x <= points[0].x) return points[0].y;
            if (x >= points[points.length - 1].x) return points[points.length - 1].y;
            
            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i + 1];
                
                if (x >= p1.x && x <= p2.x) {
                    if (p2.x === p1.x) return p1.y;
                    const t = (x - p1.x) / (p2.x - p1.x);
                    return p1.y + t * (p2.y - p1.y);
                }
            }
            
            return points[points.length - 1].y;
        }

        /**
         * Get material properties at a given elevation
         */
        function getMaterialAtY(y, profile) {
            if (!advancedMode || segments.length === 0) {
                return {
                    c: parseFloat(document.getElementById('cohesion').value),
                    phi: parseFloat(document.getElementById('frictionAngle').value) * Math.PI / 180,
                    gamma: parseFloat(document.getElementById('unitWeight').value)
                };
            }
            
            // Use segment boundaries if available
            if (profile.segmentBoundaries && profile.segmentBoundaries.length > 0) {
                for (const boundary of profile.segmentBoundaries) {
                    if (y >= boundary.startY && y <= boundary.endY) {
                        return boundary.material;
                    }
                }
                // Default to last segment's material
                const lastBoundary = profile.segmentBoundaries[profile.segmentBoundaries.length - 1];
                return lastBoundary.material;
            }
            
            // Fallback: Find which segment contains this elevation
            let currentY = 0;
            for (const seg of segments) {
                const segHeight = (seg.benchHeight || 40) * (seg.numBenches || 1);
                if (y <= currentY + segHeight) {
                    return {
                        c: seg.cohesion,
                        phi: seg.frictionAngle * Math.PI / 180,
                        gamma: seg.unitWeight
                    };
                }
                currentY += segHeight;
            }
            
            // Default to last segment
            const lastSeg = segments[segments.length - 1];
            return {
                c: lastSeg.cohesion,
                phi: lastSeg.frictionAngle * Math.PI / 180,
                gamma: lastSeg.unitWeight
            };
        }

        /**
         * Find circle-surface intersections for complex profile
         */
        function findCircleIntersections(centerX, centerY, radius, profile) {
            const intersections = [];
            const numPoints = 720;
            
            for (let i = 0; i < numPoints; i++) {
                const theta = -Math.PI + (2 * Math.PI * i) / numPoints;
                const x = centerX + radius * Math.cos(theta);
                const y = centerY + radius * Math.sin(theta);
                const surfaceY = getSurfaceY(x, profile);
                const diff = y - surfaceY;
                
                const theta2 = -Math.PI + (2 * Math.PI * (i + 1)) / numPoints;
                const x2 = centerX + radius * Math.cos(theta2);
                const y2 = centerY + radius * Math.sin(theta2);
                const surfaceY2 = getSurfaceY(x2, profile);
                const diff2 = y2 - surfaceY2;
                
                if (diff * diff2 < 0) {
                    const t = Math.abs(diff) / (Math.abs(diff) + Math.abs(diff2));
                    intersections.push({
                        x: x + t * (x2 - x),
                        y: y + t * (y2 - y),
                        theta: theta + t * (theta2 - theta)
                    });
                }
            }
            
            intersections.sort((a, b) => a.x - b.x);
            return intersections;
        }

        /**
         * Modified Bishop calculation with variable materials and Ru support
         */
        function calculateBishopFOS(centerX, centerY, radius, profile, poreParams, numSlices) {
            const intersections = findCircleIntersections(centerX, centerY, radius, profile);
            
            if (intersections.length < 2) return { fos: Infinity, valid: false };
            
            const entryPoint = intersections[0];
            const exitPoint = intersections[intersections.length - 1];
            
            // Check subsurface
            let hasSubsurface = false;
            for (let i = 1; i < 50; i++) {
                const t = i / 50;
                const checkX = entryPoint.x + t * (exitPoint.x - entryPoint.x);
                const dx = checkX - centerX;
                const disc = radius * radius - dx * dx;
                if (disc < 0) continue;
                const checkY = centerY - Math.sqrt(disc);
                if (checkY < getSurfaceY(checkX, profile) - 0.5) {
                    hasSubsurface = true;
                    break;
                }
            }
            
            if (!hasSubsurface) return { fos: Infinity, valid: false };
            
            const xStart = entryPoint.x;
            const xEnd = exitPoint.x;
            const sliceWidth = (xEnd - xStart) / numSlices;
            
            if (sliceWidth <= 0) return { fos: Infinity, valid: false };
            
            const H = profile.totalHeight;
            const gammaW = 62.4;
            
            // Pore pressure model parameters
            const ppModel = poreParams.model || 'none';
            const waterTableY = (ppModel === 'watertable' || ppModel === 'combined') 
                ? (H - poreParams.waterTableDepth) : -Infinity;
            const ru = (ppModel === 'ru' || ppModel === 'combined') 
                ? poreParams.ru : 0;
            
            const slices = [];
            let totalWeight = 0;
            let totalArcLength = 0;
            
            for (let i = 0; i < numSlices; i++) {
                const xMid = xStart + (i + 0.5) * sliceWidth;
                const surfaceY = getSurfaceY(xMid, profile);
                
                const dx = xMid - centerX;
                const disc = radius * radius - dx * dx;
                if (disc < 0) continue;
                
                const baseY = centerY - Math.sqrt(disc);
                if (baseY >= surfaceY) continue;
                
                const sliceHeight = surfaceY - baseY;
                if (sliceHeight <= 0) continue;
                
                // Get material at slice center elevation
                const midY = (surfaceY + baseY) / 2;
                const mat = getMaterialAtY(midY, profile);
                
                const alpha = Math.atan2(xMid - centerX, centerY - baseY);
                const W = mat.gamma * sliceWidth * sliceHeight;
                totalWeight += W;
                totalArcLength += Math.abs(sliceWidth / Math.cos(alpha));
                
                // Calculate pore pressure based on model
                let u = 0;
                let uFromWT = 0;
                let uFromRu = 0;
                
                if (ppModel === 'watertable' && baseY < waterTableY) {
                    // Traditional water table approach
                    uFromWT = gammaW * (waterTableY - baseY);
                    u = uFromWT;
                } else if (ppModel === 'ru') {
                    // Ru approach: u = ru * œÉv = ru * Œ≥ * h
                    // Using total vertical stress at slice base
                    const totalStress = mat.gamma * sliceHeight;
                    uFromRu = ru * totalStress;
                    u = uFromRu;
                } else if (ppModel === 'combined') {
                    // Combined: Water table + Ru for additional pressure below WT
                    if (baseY < waterTableY) {
                        uFromWT = gammaW * (waterTableY - baseY);
                        // Ru applies to the saturated portion below water table
                        const saturatedHeight = waterTableY - baseY;
                        const totalStressBelowWT = mat.gamma * saturatedHeight;
                        uFromRu = ru * totalStressBelowWT;
                        u = uFromWT + uFromRu;
                    }
                }
                
                slices.push({
                    index: i + 1,
                    x: xMid,
                    width: sliceWidth,
                    height: sliceHeight,
                    baseY, surfaceY,
                    W, u, uFromWT, uFromRu,
                    c: mat.c,
                    phi: mat.phi,
                    gamma: mat.gamma,
                    alpha,
                    alphaDeg: alpha * 180 / Math.PI,
                    sinAlpha: Math.sin(alpha),
                    cosAlpha: Math.cos(alpha),
                    tanPhi: Math.tan(mat.phi)
                });
            }
            
            if (slices.length === 0) return { fos: Infinity, valid: false };
            
            let sumDriving = slices.reduce((sum, s) => sum + s.W * s.sinAlpha, 0);
            if (sumDriving <= 0) return { fos: Infinity, valid: false };
            
            // Iterative solution
            let FoS = 1.5;
            for (let iter = 0; iter < 50; iter++) {
                let sumResisting = 0;
                
                for (const s of slices) {
                    const m_alpha = s.cosAlpha + (s.sinAlpha * s.tanPhi) / FoS;
                    if (m_alpha <= 0.1) continue;
                    s.m_alpha = m_alpha;
                    const effNormal = s.W - s.u * s.width;
                    s.resisting = (s.c * s.width + effNormal * s.tanPhi) / m_alpha;
                    s.driving = s.W * s.sinAlpha;
                    sumResisting += s.resisting;
                }
                
                const newFoS = sumResisting / sumDriving;
                if (Math.abs(newFoS - FoS) < 0.0001) { FoS = newFoS; break; }
                FoS = 0.7 * newFoS + 0.3 * FoS;
            }
            
            // Final pass
            let sumResisting = 0;
            for (const s of slices) {
                const m_alpha = s.cosAlpha + (s.sinAlpha * s.tanPhi) / FoS;
                s.m_alpha = m_alpha;
                const effNormal = s.W - s.u * s.width;
                s.resisting = (s.c * s.width + effNormal * s.tanPhi) / m_alpha;
                sumResisting += s.resisting;
            }
            
            const maxDepth = Math.max(...slices.map(s => s.surfaceY - s.baseY));
            
            if (!isFinite(FoS) || FoS <= 0 || FoS > 100) return { fos: Infinity, valid: false };
            
            return {
                fos: FoS, valid: true,
                centerX, centerY, radius,
                entryX: entryPoint.x, entryY: entryPoint.y,
                exitX: exitPoint.x, exitY: exitPoint.y,
                maxDepth, slices, totalWeight, totalArcLength,
                sumResisting, sumDriving
            };
        }

        function runAnalysis() {
            const profile = buildSlopeProfile();
            const H = profile.totalHeight;
            const xCrest = profile.xCrest;
            
            const poreParams = getPorePressureParams();
            const gridDensity = parseInt(document.getElementById('gridDensity').value);
            const numSlices = parseInt(document.getElementById('numSlices').value);
            
            // Get independent limits
            const limits = getLimits();
            const toeMin = limits.toeMin;  // Entry point minimum (negative = left of toe)
            const toeMax = limits.toeMax;  // Entry point maximum (positive = right of toe)
            const crestMin = limits.crestMin;  // Exit point minimum (negative = left of crest)
            const crestMax = limits.crestMax;  // Exit point maximum (positive = right of crest)
            
            // Get depth and radius constraints
            const constraints = getConstraints();
            const maxDepth = constraints.maxDepth;
            const minRadius = constraints.minRadius;
            const maxRadius = constraints.maxRadius;
            
            const results = [];
            
            // Grid search - search area covers the full range of possible circles
            const searchXMin = Math.min(toeMin, 0) - 20;
            const searchXMax = xCrest + Math.max(crestMax, 0) + 20;
            const yMin = H * 0.5;
            const yMax = H * 3;
            
            for (let ix = 0; ix <= gridDensity; ix++) {
                const centerX = searchXMin + (searchXMax - searchXMin) * ix / gridDensity;
                for (let iy = 0; iy <= gridDensity; iy++) {
                    const centerY = yMin + (yMax - yMin) * iy / gridDensity;
                    
                    // Use constrained radius range
                    const calcMinR = Math.max(minRadius, 10);
                    const calcMaxR = Math.min(maxRadius, Math.sqrt(centerX * centerX + centerY * centerY) + H);
                    
                    if (calcMinR >= calcMaxR) continue;
                    
                    for (let ir = 0; ir < 8; ir++) {
                        const radius = calcMinR + (calcMaxR - calcMinR) * ir / 7;
                        const result = calculateBishopFOS(centerX, centerY, radius, profile, poreParams, numSlices);
                        
                        if (!result.valid) continue;
                        
                        // Check if entry and exit points are within the independent limits
                        const entryOK = result.entryX >= toeMin && result.entryX <= toeMax;
                        const exitOK = result.exitX >= (xCrest + crestMin) && result.exitX <= (xCrest + crestMax);
                        
                        // Also check that entry is below (lower X than) exit for valid circular failure
                        const geometryOK = result.entryX < result.exitX;
                        
                        // Check depth constraint
                        const depthOK = result.maxDepth <= maxDepth;
                        
                        if (entryOK && exitOK && geometryOK && depthOK) {
                            results.push({ ...result, profile, xCrest, totalHeight: H });
                        }
                    }
                }
            }
            
            if (results.length === 0) {
                // Provide more specific guidance
                const entryMidX = (toeMin + toeMax) / 2;
                const exitMidX = xCrest + (crestMin + crestMax) / 2;
                if (entryMidX >= exitMidX) {
                    alert('No valid failure surfaces found.\n\nThe entry zone appears to be at or above the exit zone. For a valid circular failure, the entry (toe) must be below the exit (crest) on the slope.\n\nTry moving the entry zone downslope or the exit zone upslope.');
                } else {
                    alert('No valid failure surfaces found within the specified constraints.\n\nTry:\n‚Ä¢ Increasing max depth (currently ' + maxDepth.toFixed(0) + ' ft)\n‚Ä¢ Widening the radius range (' + minRadius + ' - ' + maxRadius + ' ft)\n‚Ä¢ Widening the search zones\n‚Ä¢ Increasing the grid density');
                }
                return;
            }
            
            results.sort((a, b) => a.fos - b.fos);
            
            // Refinement
            const best = results[0];
            const refR = Math.max(H * 0.1, 10);
            
            for (let dx = -5; dx <= 5; dx++) {
                for (let dy = -5; dy <= 5; dy++) {
                    for (let dr = -5; dr <= 5; dr++) {
                        const cx = best.centerX + dx * refR / 5;
                        const cy = best.centerY + dy * refR / 5;
                        const r = best.radius + dr * refR / 5;
                        
                        // Check radius constraints
                        if (r < minRadius || r > maxRadius) continue;
                        
                        const result = calculateBishopFOS(cx, cy, r, profile, poreParams, numSlices);
                        if (!result.valid) continue;
                        
                        const entryOK = result.entryX >= toeMin && result.entryX <= toeMax;
                        const exitOK = result.exitX >= (xCrest + crestMin) && result.exitX <= (xCrest + crestMax);
                        const geometryOK = result.entryX < result.exitX;
                        const depthOK = result.maxDepth <= maxDepth;
                        
                        if (entryOK && exitOK && geometryOK && depthOK && result.fos < results[0].fos) {
                            results.unshift({ ...result, profile, xCrest, totalHeight: H });
                        }
                    }
                }
            }
            
            results.sort((a, b) => a.fos - b.fos);
            
            lastAnalysisResult = {
                critical: results[0],
                profile: profile,
                inputs: {
                    H, poreParams, numSlices,
                    advancedMode, segments: [...segments],
                    limits: limits
                }
            };
            
            const toShow = results.slice(0, 40);
            showResults(toShow);
            visualizeSlope(toShow, profile, poreParams, limits);
            showCalculationDetails();
        }

        function showResults(results) {
            document.getElementById('resultsPanel').style.display = 'block';
            const c = results[0];
            
            // Primary FoS display
            document.getElementById('minFos').innerHTML = c.fos.toFixed(3);
            document.getElementById('minFos').className = 'result-value ' + (c.fos < 1.3 ? 'danger' : c.fos < 1.5 ? 'warning' : 'safe');
            
            // FoS status text
            let fosStatus = '';
            if (c.fos < 1.0) fosStatus = 'CRITICAL - Failure Expected';
            else if (c.fos < 1.3) fosStatus = 'Unstable - Below Minimum';
            else if (c.fos < 1.5) fosStatus = 'Marginal - Monitor Closely';
            else fosStatus = 'Acceptable';
            document.getElementById('fosStatus').innerHTML = fosStatus;
            
            // Critical surface geometry
            document.getElementById('entryPoint').innerHTML = `${c.entryX >= 0 ? '+' : ''}${c.entryX.toFixed(1)}' from toe`;
            document.getElementById('exitPoint').innerHTML = `${(c.exitX - c.xCrest) >= 0 ? '+' : ''}${(c.exitX - c.xCrest).toFixed(1)}' from crest`;
            document.getElementById('criticalDepth').innerHTML = c.maxDepth.toFixed(1) + ' ft';
            document.getElementById('surfaceLength').innerHTML = c.totalArcLength.toFixed(0) + ' ft';
            document.getElementById('circleRadius').innerHTML = c.radius.toFixed(1) + ' ft';
            document.getElementById('circleCenter').innerHTML = `(${c.centerX.toFixed(0)}, ${c.centerY.toFixed(0)})`;
            
            // Mass estimation
            const area = c.slices.reduce((sum, s) => sum + s.width * s.height, 0);
            document.getElementById('crossSectionArea').innerHTML = area.toFixed(0) + ' ft¬≤';
            document.getElementById('slideWeight').innerHTML = (c.totalWeight / 2000).toFixed(0) + ' tons/ft';
            
            // Force summary
            document.getElementById('sumResisting').innerHTML = c.sumResisting.toFixed(0) + ' lb/ft';
            document.getElementById('sumDriving').innerHTML = c.sumDriving.toFixed(0) + ' lb/ft';
            
            window.currentCrossSection = area;
            window.currentMass = c.totalWeight / 2000;
            window.currentUnitWeight = c.slices.length > 0 ? c.slices[0].gamma : 125;
            updateVolumeEstimate();
            
            // Warning banner
            const banner = document.getElementById('warningBanner');
            const txt = `Analyzed ${results.length} surfaces. `;
            if (c.fos < 1.0) banner.innerHTML = `<div class="warning-banner">${txt}‚ö† CRITICAL: FoS < 1.0</div>`;
            else if (c.fos < 1.3) banner.innerHTML = `<div class="warning-banner">${txt}‚ö† WARNING: FoS < 1.3</div>`;
            else if (c.fos < 1.5) banner.innerHTML = `<div class="warning-banner" style="background:rgba(224,175,104,0.1);border-color:var(--accent-warning);color:var(--accent-warning);">${txt}‚ö† MARGINAL: FoS < 1.5</div>`;
            else banner.innerHTML = `<div class="info-banner">${txt}‚úì FoS ‚â• 1.5</div>`;
            
            // Enable PDF export
            enablePDFExport();
        }

        function updateVolumeEstimate() {
            const w = parseFloat(document.getElementById('failureWidth').value) || 100;
            if (window.currentCrossSection) {
                const vol = window.currentCrossSection * w / 27;
                const tons = window.currentMass * w;
                document.getElementById('totalVolume').innerHTML = Math.round(vol).toLocaleString() + ' yd¬≥';
                document.getElementById('totalTonnage').innerHTML = Math.round(tons).toLocaleString() + ' tons';
            }
        }

        function showCalculationDetails() {
            if (!lastAnalysisResult) return;
            document.getElementById('calcPanel').style.display = 'block';
            
            const { critical, inputs } = lastAnalysisResult;
            
            // Build input summary
            let inputHtml = '';
            if (inputs.advancedMode && inputs.segments.length > 0) {
                inputHtml = inputs.segments.map((s, i) => `
                    <div class="equation-term">
                        <span class="symbol">Seg ${i+1}</span>
                        <div class="description">c'=${s.cohesion}psf, œÜ'=${s.frictionAngle}¬∞, Œ≥=${s.unitWeight}pcf</div>
                    </div>
                `).join('');
            } else {
                const c = parseFloat(document.getElementById('cohesion').value);
                const phi = parseFloat(document.getElementById('frictionAngle').value);
                const gamma = parseFloat(document.getElementById('unitWeight').value);
                inputHtml = `
                    <div class="equation-term"><span class="symbol">c'</span> <span class="value">${c} psf</span></div>
                    <div class="equation-term"><span class="symbol">œÜ'</span> <span class="value">${phi}¬∞</span></div>
                    <div class="equation-term"><span class="symbol">Œ≥</span> <span class="value">${gamma} pcf</span></div>
                `;
            }
            document.getElementById('inputSummary').innerHTML = inputHtml;
            
            // Slice table
            const tbody = document.getElementById('sliceTableBody');
            tbody.innerHTML = '';
            let totR = 0, totD = 0;
            
            for (const s of critical.slices) {
                totR += s.resisting;
                totD += s.driving;
                tbody.innerHTML += `<tr>
                    <td>${s.index}</td>
                    <td>${s.x.toFixed(0)}</td>
                    <td>${s.width.toFixed(1)}</td>
                    <td>${s.height.toFixed(0)}</td>
                    <td>${s.W.toFixed(0)}</td>
                    <td>${s.alphaDeg.toFixed(1)}</td>
                    <td>${s.u.toFixed(0)}</td>
                    <td>${s.m_alpha.toFixed(3)}</td>
                    <td>${s.resisting.toFixed(0)}</td>
                    <td>${s.driving.toFixed(0)}</td>
                </tr>`;
            }
            tbody.innerHTML += `<tr class="sum-row">
                <td colspan="8" style="text-align:right;">Œ£ ‚Üí</td>
                <td>${totR.toFixed(0)}</td>
                <td>${totD.toFixed(0)}</td>
            </tr>`;
            
            const cls = critical.fos < 1.3 ? 'danger' : critical.fos < 1.5 ? 'warning' : 'safe';
            document.getElementById('summaryCalc').innerHTML = `
                <div class="final-equation">FoS = ${totR.toFixed(0)} / ${totD.toFixed(0)}</div>
                <div class="final-result ${cls}">${critical.fos.toFixed(4)}</div>
            `;
        }

        function toggleSliceTable() {
            const d = document.getElementById('sliceDetails');
            const btn = document.querySelector('.toggle-details');
            d.classList.toggle('show');
            btn.textContent = d.classList.contains('show') ? '‚ñ≤ Hide Slice Calculations' : '‚ñº Show Slice Calculations';
        }

        function visualizeSlope(results, profile, poreParams, limits) {
            const canvas = document.getElementById('slopeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.length === 0) return;
            
            // Extract independent limits
            const { toeMin, toeMax, crestMin, crestMax } = limits;
            
            const critical = results[0];
            const H = profile.totalHeight;
            const xCrest = profile.xCrest;
            const margin = 50;
            
            // Calculate bounds - add extra space on right for annotations
            let minX = Math.min(toeMin - 10, critical.entryX - 20);
            let maxX = Math.max(xCrest + crestMax + 10, critical.exitX + 20);
            
            // Add extra space for segment labels on the right
            if (!profile.simple && advancedMode) {
                maxX = Math.max(maxX, xCrest + 180);
            }
            
            let minY = -H * 0.08;
            let maxY = H * 1.12;
            
            for (const r of results.slice(0, 15)) {
                minX = Math.min(minX, r.entryX - 10);
                maxX = Math.max(maxX, r.exitX + 10);
                minY = Math.min(minY, r.centerY - r.radius - 5);
            }
            
            const scaleX = (canvas.width - 2 * margin) / (maxX - minX);
            const scaleY = (canvas.height - 2 * margin) / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);
            
            const offX = margin + (canvas.width - 2 * margin - (maxX - minX) * scale) / 2;
            const offY = margin + (canvas.height - 2 * margin - (maxY - minY) * scale) / 2;
            
            const toX = x => offX + (x - minX) * scale;
            const toY = y => canvas.height - offY - (y - minY) * scale;
            const fromX = px => (px - offX) / scale + minX;
            
            // Store visualization state for interactive dragging
            vizState = {
                toX, toY, fromX, scale, minX, maxX, minY, maxY,
                H, xCrest, limits,
                zTop: Math.min(H * 1.05, maxY),
                zBot: Math.max(-5, minY)
            };
            
            const zTop = vizState.zTop;
            const zBot = vizState.zBot;
            
            // Search zones (subtle shading) - now asymmetric
            ctx.fillStyle = 'rgba(247,118,142,0.06)';
            // Toe zone
            const toeZoneLeft = toX(toeMin);
            const toeZoneWidth = (toeMax - toeMin) * scale;
            ctx.fillRect(toeZoneLeft, toY(zTop), toeZoneWidth, (zTop-zBot)*scale);
            // Crest zone
            const crestZoneLeft = toX(xCrest + crestMin);
            const crestZoneWidth = (crestMax - crestMin) * scale;
            ctx.fillRect(crestZoneLeft, toY(zTop), crestZoneWidth, (zTop-zBot)*scale);
            
            // Draw limit lines with drag handles
            drawLimitLines(ctx, toX, toY, limits, xCrest, zTop, zBot, H);
            
            // Non-critical arcs
            for (let i = Math.min(results.length-1, 12); i >= 1; i--) {
                drawArc(ctx, results[i], toX, toY, profile, false);
            }
            
            // Critical arc
            drawArc(ctx, critical, toX, toY, profile, true);
            
            // Draw slope profile
            ctx.strokeStyle = '#c0caf5';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(toX(minX), toY(0));
            ctx.lineTo(toX(0), toY(0));
            
            for (const p of profile.points) {
                ctx.lineTo(toX(p.x), toY(p.y));
            }
            ctx.lineTo(toX(maxX), toY(H));
            ctx.stroke();
            
            // Fill slope body
            ctx.fillStyle = 'rgba(192,202,245,0.1)';
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(0));
            for (const p of profile.points) {
                ctx.lineTo(toX(p.x), toY(p.y));
            }
            ctx.lineTo(toX(xCrest), toY(0));
            ctx.closePath();
            ctx.fill();
            
            // Draw segment annotations for advanced mode
            if (!profile.simple && advancedMode && segments.length > 0) {
                drawSegmentAnnotations(ctx, toX, toY, profile, H, xCrest);
            }
            
            // Draw overall slope angle line and label
            ctx.strokeStyle = 'rgba(158, 206, 106, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(0));
            ctx.lineTo(toX(xCrest), toY(H));
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Overall slope angle label
            const overallAngle = Math.atan(H / xCrest) * 180 / Math.PI;
            ctx.fillStyle = '#9ece6a';
            ctx.font = 'bold 12px JetBrains Mono';
            const oaLabelX = xCrest * 0.35;
            const oaLabelY = H * 0.35;
            ctx.fillText(`OSA: ${overallAngle.toFixed(1)}¬∞`, toX(oaLabelX) - 20, toY(oaLabelY) + 20);
            
            // Water table and pore pressure indicators
            const ppModel = poreParams.model;
            if (ppModel === 'watertable' || ppModel === 'combined') {
                const wY = H - poreParams.waterTableDepth;
                ctx.strokeStyle = '#7aa2f7';
                ctx.lineWidth = 2;
                ctx.setLineDash([8,4]);
                ctx.beginPath();
                ctx.moveTo(toX(minX), toY(wY));
                ctx.lineTo(toX(maxX), toY(wY));
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#7aa2f7';
                ctx.font = '11px JetBrains Mono';
                ctx.fillText('‚ñº WT', toX(minX)+5, toY(wY)-4);
            }
            
            // Ru indicator
            if (ppModel === 'ru' || ppModel === 'combined') {
                ctx.fillStyle = 'rgba(122, 162, 247, 0.7)';
                ctx.font = 'bold 11px JetBrains Mono';
                const ruLabel = `Ru = ${poreParams.ru.toFixed(2)}`;
                ctx.fillText(ruLabel, toX(maxX) - 80, toY(H) + 20);
            }
            
            // Height label
            ctx.fillStyle = '#a9b1d6';
            ctx.font = 'bold 13px JetBrains Mono';
            ctx.fillText(`H=${H.toFixed(0)}'`, toX(0)-50, toY(H/2));
            
            // FoS label
            ctx.fillStyle = '#ff9e64';
            ctx.font = 'bold 15px JetBrains Mono';
            const lx = (critical.entryX + critical.exitX) / 2;
            const ly = Math.max(critical.centerY, H * 0.7);
            ctx.fillText(`FoS = ${critical.fos.toFixed(3)}`, toX(lx)-50, toY(ly)-8);
        }

        /**
         * Draw segment annotations showing IRA, stepouts, and segment info
         */
        function drawSegmentAnnotations(ctx, toX, toY, profile, H, xCrest) {
            const segmentColors = ['#bb9af7', '#7aa2f7', '#9ece6a', '#e0af68', '#f7768e'];
            
            // Calculate scale from toX function
            const scale = Math.abs(toX(1) - toX(0));
            
            let currentY = 0;
            let currentX = 0;
            let segmentIndex = 0;
            
            // Track segment regions for annotations
            const segmentRegions = [];
            
            for (const seg of segments) {
                const color = segmentColors[segmentIndex % segmentColors.length];
                const numBenches = seg.numBenches || 1;
                const faceAngle = seg.benchFaceAngle * Math.PI / 180;
                
                // Calculate segment geometry
                const segStartY = currentY;
                const segStartX = currentX;
                
                // Calculate IRA for this segment
                const ira = calculateIRA(seg.benchHeight, seg.benchFaceAngle, seg.catchBenchWidth);
                
                // Track the segment's horizontal extent
                let segEndX = currentX;
                let segEndY = currentY;
                let benchCount = 0;
                
                // Process each bench in segment
                for (let b = 0; b < numBenches; b++) {
                    const benchTop = Math.min(currentY + seg.benchHeight, H);
                    const actualBenchHeight = benchTop - currentY;
                    if (actualBenchHeight <= 0) break;
                    
                    const faceRun = actualBenchHeight / Math.tan(faceAngle);
                    segEndX = currentX + faceRun;
                    segEndY = benchTop;
                    currentX = segEndX;
                    currentY = benchTop;
                    benchCount++;
                    
                    // Add catch bench
                    if (currentY < H && seg.catchBenchWidth > 0) {
                        currentX += seg.catchBenchWidth;
                        segEndX = currentX;
                    }
                    
                    if (currentY >= H) break;
                }
                
                // Store segment region info
                segmentRegions.push({
                    index: segmentIndex,
                    startX: segStartX,
                    startY: segStartY,
                    endX: segEndX,
                    endY: segEndY,
                    ira: ira,
                    benchCount: benchCount,
                    benchHeight: seg.benchHeight,
                    color: color,
                    stepoutType: seg.stepoutType,
                    stepoutWidth: seg.stepoutWidth
                });
                
                // Draw IRA line for segment (dashed line from segment start to end)
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(toX(segStartX), toY(segStartY));
                ctx.lineTo(toX(segEndX), toY(segEndY));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw IRA arc indicator near the segment base
                const arcRadius = 25;
                const arcCenterX = segStartX + 15;
                const arcCenterY = segStartY + 15;
                const iraRad = ira * Math.PI / 180;
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.arc(toX(arcCenterX), toY(arcCenterY), arcRadius, -Math.PI/2, -Math.PI/2 + iraRad, false);
                ctx.stroke();
                
                // IRA label near the arc
                ctx.fillStyle = color;
                ctx.font = 'bold 10px JetBrains Mono';
                ctx.fillText(`${ira.toFixed(1)}¬∞`, toX(arcCenterX) + arcRadius + 3, toY(arcCenterY) - 5);
                
                // Draw segment label bracket on right side
                const labelX = xCrest + 20;
                const midY = (segStartY + segEndY) / 2;
                
                // Bracket line
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(toX(labelX - 12), toY(segStartY));
                ctx.lineTo(toX(labelX), toY(segStartY));
                ctx.lineTo(toX(labelX), toY(segEndY));
                ctx.lineTo(toX(labelX - 12), toY(segEndY));
                ctx.stroke();
                
                // Horizontal tick at midpoint
                ctx.beginPath();
                ctx.moveTo(toX(labelX), toY(midY));
                ctx.lineTo(toX(labelX + 8), toY(midY));
                ctx.stroke();
                
                // Segment info text
                ctx.fillStyle = color;
                ctx.font = 'bold 11px JetBrains Mono';
                ctx.fillText(`Seg ${segmentIndex + 1}`, toX(labelX + 12), toY(midY) - 18);
                ctx.font = '10px JetBrains Mono';
                ctx.fillText(`IRA: ${ira.toFixed(1)}¬∞`, toX(labelX + 12), toY(midY) - 5);
                ctx.font = '9px JetBrains Mono';
                ctx.fillStyle = 'rgba(192, 202, 245, 0.8)';
                ctx.fillText(`${benchCount}√ó ${seg.benchHeight}' benches`, toX(labelX + 12), toY(midY) + 8);
                ctx.fillText(`Face: ${seg.benchFaceAngle}¬∞ | Catch: ${seg.catchBenchWidth}'`, toX(labelX + 12), toY(midY) + 20);
                
                // Draw stepout annotation if present
                if (seg.stepoutType !== 'none' && seg.stepoutWidth > 0 && currentY < H) {
                    const stepoutStartX = currentX;
                    currentX += seg.stepoutWidth;
                    
                    // Stepout shaded area
                    ctx.fillStyle = 'rgba(122, 162, 247, 0.2)';
                    ctx.fillRect(
                        toX(stepoutStartX), 
                        toY(currentY + 3), 
                        (currentX - stepoutStartX) * scale, 
                        6
                    );
                    
                    // Stepout dimension line
                    ctx.strokeStyle = '#7aa2f7';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(toX(stepoutStartX), toY(currentY) - 15);
                    ctx.lineTo(toX(currentX), toY(currentY) - 15);
                    ctx.stroke();
                    
                    // Dimension arrows
                    ctx.beginPath();
                    ctx.moveTo(toX(stepoutStartX), toY(currentY) - 15);
                    ctx.lineTo(toX(stepoutStartX) + 5, toY(currentY) - 18);
                    ctx.lineTo(toX(stepoutStartX) + 5, toY(currentY) - 12);
                    ctx.closePath();
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.moveTo(toX(currentX), toY(currentY) - 15);
                    ctx.lineTo(toX(currentX) - 5, toY(currentY) - 18);
                    ctx.lineTo(toX(currentX) - 5, toY(currentY) - 12);
                    ctx.closePath();
                    ctx.fill();
                    
                    // Stepout label
                    ctx.fillStyle = '#7aa2f7';
                    ctx.font = 'bold 9px JetBrains Mono';
                    const stepoutLabel = seg.stepoutType === 'ramp' ? 'RAMP' : 'GEOTECH';
                    const labelWidth = ctx.measureText(`${stepoutLabel}: ${seg.stepoutWidth}'`).width;
                    ctx.fillText(`${stepoutLabel}: ${seg.stepoutWidth}'`, 
                        toX(stepoutStartX + seg.stepoutWidth/2) - labelWidth/2, 
                        toY(currentY) - 20);
                }
                
                segmentIndex++;
                
                if (currentY >= H) break;
            }
            
            // Draw elevation scale on left side
            ctx.fillStyle = 'rgba(169, 177, 214, 0.6)';
            ctx.strokeStyle = 'rgba(169, 177, 214, 0.3)';
            ctx.font = '9px JetBrains Mono';
            
            // Calculate appropriate elevation step
            const elevStep = H <= 100 ? 25 : H <= 250 ? 50 : H <= 500 ? 100 : 200;
            
            for (let elev = 0; elev <= H; elev += elevStep) {
                const tickX = -8;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(toX(tickX), toY(elev));
                ctx.lineTo(toX(0), toY(elev));
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(169, 177, 214, 0.7)';
                ctx.fillText(`${elev}'`, toX(tickX) - 28, toY(elev) + 3);
            }
            
            // Draw "ELEV" label
            ctx.save();
            ctx.translate(toX(-25), toY(H/2));
            ctx.rotate(-Math.PI/2);
            ctx.fillStyle = 'rgba(169, 177, 214, 0.5)';
            ctx.font = 'bold 9px JetBrains Mono';
            ctx.fillText('ELEVATION', -30, 0);
            ctx.restore();
        }

        /**
         * Draw limit lines with interactive drag handles
         */
        function drawLimitLines(ctx, toX, toY, limits, xCrest, zTop, zBot, H) {
            const { toeMin, toeMax, crestMin, crestMax } = limits;
            
            const lines = [
                { id: 'toeMin', x: toeMin, label: 'Entry Min', zone: 'toe', inputId: 'toeMin' },
                { id: 'toeMax', x: toeMax, label: 'Entry Max', zone: 'toe', inputId: 'toeMax' },
                { id: 'crestMin', x: xCrest + crestMin, label: 'Exit Min', zone: 'crest', inputId: 'crestMin' },
                { id: 'crestMax', x: xCrest + crestMax, label: 'Exit Max', zone: 'crest', inputId: 'crestMax' }
            ];
            
            lines.forEach(line => {
                const px = toX(line.x);
                const isHovered = dragState.hoveredLine === line.id;
                const isDragging = dragState.active && dragState.line === line.id;
                
                // Line
                ctx.strokeStyle = isDragging ? '#ff9e64' : isHovered ? 'rgba(247,118,142,0.8)' : 'rgba(247,118,142,0.4)';
                ctx.lineWidth = isDragging ? 2 : isHovered ? 1.5 : 1;
                ctx.setLineDash([5, 3]);
                ctx.beginPath();
                ctx.moveTo(px, toY(zBot));
                ctx.lineTo(px, toY(zTop));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Drag handle (triangle at top)
                const handleY = toY(zTop) - 5;
                const handleSize = isHovered || isDragging ? 10 : 8;
                
                ctx.fillStyle = isDragging ? '#ff9e64' : isHovered ? '#f7768e' : 'rgba(247,118,142,0.6)';
                ctx.beginPath();
                ctx.moveTo(px, handleY);
                ctx.lineTo(px - handleSize, handleY - handleSize * 1.5);
                ctx.lineTo(px + handleSize, handleY - handleSize * 1.5);
                ctx.closePath();
                ctx.fill();
                
                // Handle grip lines
                ctx.strokeStyle = isDragging ? '#0a0e14' : isHovered ? '#0a0e14' : 'rgba(10,14,20,0.5)';
                ctx.lineWidth = 1;
                for (let i = -1; i <= 1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(px + i * 3, handleY - handleSize * 0.5);
                    ctx.lineTo(px + i * 3, handleY - handleSize * 1.2);
                    ctx.stroke();
                }
                
                // Value label - show actual position relative to reference point
                let displayValue;
                if (line.zone === 'toe') {
                    displayValue = line.x;
                } else {
                    displayValue = line.x - xCrest;
                }
                const sign = displayValue >= 0 ? '+' : '';
                ctx.fillStyle = isHovered || isDragging ? '#f7768e' : 'rgba(247,118,142,0.7)';
                ctx.font = 'bold 9px JetBrains Mono';
                ctx.textAlign = 'center';
                ctx.fillText(`${sign}${displayValue.toFixed(0)}'`, px, handleY - handleSize * 1.7);
                ctx.textAlign = 'left';
            });
        }

        /**
         * Get which limit line handle is at the given canvas position
         */
        function getLineAtPosition(canvasX, canvasY) {
            if (!vizState) return null;
            
            const { toX, xCrest, limits, zTop } = vizState;
            if (!limits) return null;
            
            const handleY = vizState.toY(zTop) - 5;
            const tolerance = 15;
            
            // Check if Y is near the handle area
            if (canvasY > handleY + 10 || canvasY < handleY - 25) return null;
            
            const lines = [
                { id: 'toeMin', x: limits.toeMin },
                { id: 'toeMax', x: limits.toeMax },
                { id: 'crestMin', x: xCrest + limits.crestMin },
                { id: 'crestMax', x: xCrest + limits.crestMax }
            ];
            
            for (const line of lines) {
                const px = toX(line.x);
                if (Math.abs(canvasX - px) < tolerance) {
                    return line.id;
                }
            }
            
            return null;
        }

        /**
         * Initialize canvas mouse events for dragging limit lines
         */
        function initCanvasInteraction() {
            const canvas = document.getElementById('slopeCanvas');
            
            canvas.addEventListener('mousemove', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;
                
                if (dragState.active && vizState) {
                    // Dragging a line
                    const worldX = vizState.fromX(canvasX);
                    const { xCrest } = vizState;
                    
                    let newValue;
                    switch (dragState.line) {
                        case 'toeMin':
                            // Entry min can be anywhere, but must be < toeMax
                            newValue = Math.max(-300, Math.min(xCrest, worldX));
                            newValue = Math.min(newValue, parseFloat(document.getElementById('toeMax').value) - 5);
                            setLimit('toeMin', newValue);
                            break;
                        case 'toeMax':
                            // Entry max can be anywhere, but must be > toeMin
                            newValue = Math.max(-300, Math.min(xCrest, worldX));
                            newValue = Math.max(newValue, parseFloat(document.getElementById('toeMin').value) + 5);
                            setLimit('toeMax', newValue);
                            break;
                        case 'crestMin':
                            // Exit min (relative to crest), must be < crestMax
                            newValue = Math.max(-xCrest, Math.min(300, worldX - xCrest));
                            newValue = Math.min(newValue, parseFloat(document.getElementById('crestMax').value) - 5);
                            setLimit('crestMin', newValue);
                            break;
                        case 'crestMax':
                            // Exit max (relative to crest), must be > crestMin
                            newValue = Math.max(-xCrest, Math.min(300, worldX - xCrest));
                            newValue = Math.max(newValue, parseFloat(document.getElementById('crestMin').value) + 5);
                            setLimit('crestMax', newValue);
                            break;
                    }
                    
                    // Redraw with updated limits (lightweight redraw)
                    quickRedrawLimits();
                    
                } else {
                    // Check for hover
                    const hoveredLine = getLineAtPosition(canvasX, canvasY);
                    if (hoveredLine !== dragState.hoveredLine) {
                        dragState.hoveredLine = hoveredLine;
                        canvas.style.cursor = hoveredLine ? 'ew-resize' : 'default';
                        // Redraw to show hover state
                        if (lastAnalysisResult) {
                            const { profile } = lastAnalysisResult;
                            const poreParams = getPorePressureParams();
                            const limits = getLimits();
                            visualizeSlope([lastAnalysisResult.critical], profile, poreParams, limits);
                        }
                    }
                }
            });
            
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const canvasX = (e.clientX - rect.left) * scaleX;
                const canvasY = (e.clientY - rect.top) * scaleY;
                
                const line = getLineAtPosition(canvasX, canvasY);
                if (line) {
                    dragState.active = true;
                    dragState.line = line;
                    dragState.startX = canvasX;
                    canvas.style.cursor = 'ew-resize';
                    e.preventDefault();
                }
            });
            
            canvas.addEventListener('mouseup', () => {
                if (dragState.active) {
                    dragState.active = false;
                    dragState.line = null;
                    // Run full analysis with new limits
                    runAnalysis();
                }
            });
            
            canvas.addEventListener('mouseleave', () => {
                if (dragState.active) {
                    dragState.active = false;
                    dragState.line = null;
                    runAnalysis();
                }
                dragState.hoveredLine = null;
                canvas.style.cursor = 'default';
            });
        }

        /**
         * Quick redraw of just the limit lines during drag (without full reanalysis)
         */
        function quickRedrawLimits() {
            if (!vizState || !lastAnalysisResult) return;
            
            const canvas = document.getElementById('slopeCanvas');
            const ctx = canvas.getContext('2d');
            
            const { profile, critical } = lastAnalysisResult;
            const poreParams = getPorePressureParams();
            const limits = getLimits();
            
            // Full redraw with current limits but without reanalysis
            visualizeSlopeWithResults([critical], profile, poreParams, limits);
        }

        /**
         * Visualize with pre-computed results (used during drag)
         */
        function visualizeSlopeWithResults(results, profile, poreParams, limits) {
            const canvas = document.getElementById('slopeCanvas');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (results.length === 0) return;
            
            const { toeMin, toeMax, crestMin, crestMax } = limits;
            
            const critical = results[0];
            const H = profile.totalHeight;
            const xCrest = profile.xCrest;
            const margin = 50;
            
            let minX = Math.min(toeMin - 10, critical.entryX - 20);
            let maxX = Math.max(xCrest + crestMax + 10, critical.exitX + 20);
            
            if (!profile.simple && advancedMode) {
                maxX = Math.max(maxX, xCrest + 180);
            }
            
            let minY = -H * 0.08;
            let maxY = H * 1.12;
            
            for (const r of results.slice(0, 15)) {
                minX = Math.min(minX, r.entryX - 10);
                maxX = Math.max(maxX, r.exitX + 10);
                minY = Math.min(minY, r.centerY - r.radius - 5);
            }
            
            const scaleX = (canvas.width - 2 * margin) / (maxX - minX);
            const scaleY = (canvas.height - 2 * margin) / (maxY - minY);
            const scale = Math.min(scaleX, scaleY);
            
            const offX = margin + (canvas.width - 2 * margin - (maxX - minX) * scale) / 2;
            const offY = margin + (canvas.height - 2 * margin - (maxY - minY) * scale) / 2;
            
            const toX = x => offX + (x - minX) * scale;
            const toY = y => canvas.height - offY - (y - minY) * scale;
            const fromX = px => (px - offX) / scale + minX;
            
            vizState = {
                toX, toY, fromX, scale, minX, maxX, minY, maxY,
                H, xCrest, limits,
                zTop: Math.min(H * 1.05, maxY),
                zBot: Math.max(-5, minY)
            };
            
            const zTop = vizState.zTop;
            const zBot = vizState.zBot;
            
            // Search zones - asymmetric
            ctx.fillStyle = 'rgba(247,118,142,0.06)';
            const toeZoneLeft = toX(toeMin);
            const toeZoneWidth = (toeMax - toeMin) * scale;
            ctx.fillRect(toeZoneLeft, toY(zTop), toeZoneWidth, (zTop-zBot)*scale);
            const crestZoneLeft = toX(xCrest + crestMin);
            const crestZoneWidth = (crestMax - crestMin) * scale;
            ctx.fillRect(crestZoneLeft, toY(zTop), crestZoneWidth, (zTop-zBot)*scale);
            
            // Draw limit lines with handles
            drawLimitLines(ctx, toX, toY, limits, xCrest, zTop, zBot, H);
            
            // Critical arc only during drag
            drawArc(ctx, critical, toX, toY, profile, true);
            
            // Slope profile
            ctx.strokeStyle = '#c0caf5';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(toX(minX), toY(0));
            ctx.lineTo(toX(0), toY(0));
            for (const p of profile.points) {
                ctx.lineTo(toX(p.x), toY(p.y));
            }
            ctx.lineTo(toX(maxX), toY(H));
            ctx.stroke();
            
            // Slope fill
            ctx.fillStyle = 'rgba(192,202,245,0.1)';
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(0));
            for (const p of profile.points) {
                ctx.lineTo(toX(p.x), toY(p.y));
            }
            ctx.lineTo(toX(xCrest), toY(0));
            ctx.closePath();
            ctx.fill();
            
            // Segment annotations
            if (!profile.simple && advancedMode && segments.length > 0) {
                drawSegmentAnnotations(ctx, toX, toY, profile, H, xCrest);
            }
            
            // Overall slope angle
            ctx.strokeStyle = 'rgba(158, 206, 106, 0.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 5]);
            ctx.beginPath();
            ctx.moveTo(toX(0), toY(0));
            ctx.lineTo(toX(xCrest), toY(H));
            ctx.stroke();
            ctx.setLineDash([]);
            
            const overallAngle = Math.atan(H / xCrest) * 180 / Math.PI;
            ctx.fillStyle = '#9ece6a';
            ctx.font = 'bold 12px JetBrains Mono';
            ctx.fillText(`OSA: ${overallAngle.toFixed(1)}¬∞`, toX(xCrest * 0.35) - 20, toY(H * 0.35) + 20);
            
            // Water table and Ru
            const ppModel = poreParams.model;
            if (ppModel === 'watertable' || ppModel === 'combined') {
                const wY = H - poreParams.waterTableDepth;
                ctx.strokeStyle = '#7aa2f7';
                ctx.lineWidth = 2;
                ctx.setLineDash([8,4]);
                ctx.beginPath();
                ctx.moveTo(toX(minX), toY(wY));
                ctx.lineTo(toX(maxX), toY(wY));
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.fillStyle = '#7aa2f7';
                ctx.font = '11px JetBrains Mono';
                ctx.fillText('‚ñº WT', toX(minX)+5, toY(wY)-4);
            }
            
            if (ppModel === 'ru' || ppModel === 'combined') {
                ctx.fillStyle = 'rgba(122, 162, 247, 0.7)';
                ctx.font = 'bold 11px JetBrains Mono';
                ctx.fillText(`Ru = ${poreParams.ru.toFixed(2)}`, toX(maxX) - 80, toY(H) + 20);
            }
            
            // Labels
            ctx.fillStyle = '#a9b1d6';
            ctx.font = 'bold 13px JetBrains Mono';
            ctx.fillText(`H=${H.toFixed(0)}'`, toX(0)-50, toY(H/2));
            
            ctx.fillStyle = '#ff9e64';
            ctx.font = 'bold 15px JetBrains Mono';
            const lx = (critical.entryX + critical.exitX) / 2;
            const ly = Math.max(critical.centerY, H * 0.7);
            ctx.fillText(`FoS = ${critical.fos.toFixed(3)}`, toX(lx)-50, toY(ly)-8);
        }

        function drawArc(ctx, r, toX, toY, profile, isCritical) {
            const { centerX, centerY, radius, entryX, entryY, exitX, exitY } = r;
            const ea = -Math.atan2(entryY - centerY, entryX - centerX);
            const xa = -Math.atan2(exitY - centerY, exitX - centerX);
            const cx = toX(centerX), cy = toY(centerY);
            const rad = radius * Math.abs(toX(1) - toX(0));
            
            if (isCritical) {
                ctx.fillStyle = 'rgba(255,158,100,0.25)';
                ctx.beginPath();
                ctx.moveTo(toX(entryX), toY(entryY));
                ctx.arc(cx, cy, rad, ea, xa, true);
                for (let i = 25; i >= 0; i--) {
                    const t = i/25;
                    const x = entryX + t*(exitX-entryX);
                    ctx.lineTo(toX(x), toY(getSurfaceY(x, profile)));
                }
                ctx.closePath();
                ctx.fill();
                
                ctx.strokeStyle = '#ff9e64';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(cx, cy, rad, ea, xa, true);
                ctx.stroke();
                
                // Tension crack
                ctx.lineWidth = 2;
                ctx.setLineDash([5,3]);
                ctx.beginPath();
                ctx.moveTo(toX(exitX), toY(exitY));
                ctx.lineTo(toX(exitX), toY(getSurfaceY(exitX, profile)));
                ctx.stroke();
                ctx.setLineDash([]);
                
                ctx.fillStyle = '#ff9e64';
                ctx.beginPath();
                ctx.arc(cx, cy, 4, 0, 2*Math.PI);
                ctx.fill();
            } else {
                const fos = r.fos;
                const col = fos < 1.3 ? '#f7768e' : fos < 1.5 ? '#e0af68' : '#9ece6a';
                const alp = fos < 1.3 ? 0.08 : fos < 1.5 ? 0.05 : 0.03;
                
                ctx.fillStyle = col;
                ctx.globalAlpha = alp;
                ctx.beginPath();
                ctx.moveTo(toX(entryX), toY(entryY));
                ctx.arc(cx, cy, rad, ea, xa, true);
                for (let i = 20; i >= 0; i--) {
                    const t = i/20;
                    const x = entryX + t*(exitX-entryX);
                    ctx.lineTo(toX(x), toY(getSurfaceY(x, profile)));
                }
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                
                ctx.strokeStyle = col;
                ctx.lineWidth = 1;
                ctx.globalAlpha = 0.25;
                ctx.beginPath();
                ctx.arc(cx, cy, rad, ea, xa, true);
                ctx.stroke();
                ctx.globalAlpha = 1;
            }
        }

        // ============================================
        // SENSITIVITY ANALYSIS FUNCTIONS
        // ============================================

        const sensitivityParams = {
            cohesion: { 
                label: "Cohesion, c' (psf)", 
                unit: 'psf',
                defaultMin: 0, 
                defaultMax: 1000,
                getValue: () => parseFloat(document.getElementById('cohesion').value),
                setValue: (v) => document.getElementById('cohesion').value = v
            },
            frictionAngle: { 
                label: "Friction Angle, œÜ' (¬∞)", 
                unit: '¬∞',
                defaultMin: 15, 
                defaultMax: 45,
                getValue: () => parseFloat(document.getElementById('frictionAngle').value),
                setValue: (v) => { 
                    document.getElementById('frictionAngle').value = v;
                    document.getElementById('frictionAngleValue').textContent = v + '¬∞';
                }
            },
            unitWeight: { 
                label: "Unit Weight, Œ≥ (pcf)", 
                unit: 'pcf',
                defaultMin: 100, 
                defaultMax: 160,
                getValue: () => parseFloat(document.getElementById('unitWeight').value),
                setValue: (v) => document.getElementById('unitWeight').value = v
            },
            slopeHeight: { 
                label: "Slope Height, H (ft)", 
                unit: 'ft',
                defaultMin: 50, 
                defaultMax: 300,
                getValue: () => parseFloat(document.getElementById('slopeHeight').value),
                setValue: (v) => document.getElementById('slopeHeight').value = v
            },
            slopeAngle: { 
                label: "Slope Angle, Œ≤ (¬∞)", 
                unit: '¬∞',
                defaultMin: 25, 
                defaultMax: 60,
                getValue: () => parseFloat(document.getElementById('slopeAngle').value),
                setValue: (v) => {
                    document.getElementById('slopeAngle').value = v;
                    document.getElementById('slopeAngleValue').textContent = v + '¬∞';
                }
            },
            waterTable: { 
                label: "Water Table Depth (ft)", 
                unit: 'ft',
                defaultMin: 0, 
                defaultMax: 200,
                getValue: () => parseFloat(document.getElementById('waterTable').value),
                setValue: (v) => {
                    document.getElementById('waterTable').value = v;
                    document.getElementById('waterTableValue').textContent = v + ' ft';
                },
                requiresModel: 'watertable'
            },
            ruCoeff: { 
                label: "Ru Coefficient", 
                unit: '',
                defaultMin: 0, 
                defaultMax: 0.5,
                getValue: () => parseFloat(document.getElementById('ruCoeff').value),
                setValue: (v) => {
                    document.getElementById('ruCoeff').value = v;
                    document.getElementById('ruValue').textContent = v.toFixed(2);
                },
                requiresModel: 'ru'
            }
        };

        function updateSensitivityRange() {
            const param = document.getElementById('sensitivityParam').value;
            const config = sensitivityParams[param];
            if (config) {
                const currentVal = config.getValue();
                // Set range around current value, or use defaults
                document.getElementById('sensitivityMin').value = config.defaultMin;
                document.getElementById('sensitivityMax').value = config.defaultMax;
            }
        }

        function runSensitivityAnalysis() {
            const paramKey = document.getElementById('sensitivityParam').value;
            const config = sensitivityParams[paramKey];
            if (!config) return;

            const minVal = parseFloat(document.getElementById('sensitivityMin').value);
            const maxVal = parseFloat(document.getElementById('sensitivityMax').value);
            const steps = parseInt(document.getElementById('sensitivitySteps').value) || 10;

            if (minVal >= maxVal) {
                alert('Min value must be less than max value');
                return;
            }

            // Store original value
            const originalValue = config.getValue();
            
            // Store original pore pressure model and set appropriate model for sensitivity
            const originalPPModel = document.getElementById('porePressureModel').value;
            
            // If analyzing water table or Ru, ensure appropriate model is set
            if (paramKey === 'waterTable' && originalPPModel === 'none') {
                document.getElementById('porePressureModel').value = 'watertable';
                updatePorePressureUI();
            } else if (paramKey === 'ruCoeff' && originalPPModel === 'none') {
                document.getElementById('porePressureModel').value = 'ru';
                updatePorePressureUI();
            }

            const results = [];
            const stepSize = (maxVal - minVal) / (steps - 1);

            // Run analysis for each parameter value
            for (let i = 0; i < steps; i++) {
                const paramValue = minVal + i * stepSize;
                config.setValue(paramValue);

                // Build profile and run single FoS calculation using current critical surface
                const profile = buildSlopeProfile();
                const H = profile.totalHeight;
                const xCrest = profile.xCrest;
                const poreParams = getPorePressureParams();
                const numSlices = parseInt(document.getElementById('numSlices').value);
                const limits = getLimits();
                const constraints = getConstraints();

                // Use a quick grid search to find critical surface for this configuration
                const gridDensity = 8; // Reduced for speed
                let bestFos = Infinity;
                let bestResult = null;

                const searchXMin = Math.min(limits.toeMin, 0) - 20;
                const searchXMax = xCrest + Math.max(limits.crestMax, 0) + 20;
                const yMin = H * 0.5;
                const yMax = H * 2.5;

                for (let ix = 0; ix <= gridDensity; ix++) {
                    const centerX = searchXMin + (searchXMax - searchXMin) * ix / gridDensity;
                    for (let iy = 0; iy <= gridDensity; iy++) {
                        const centerY = yMin + (yMax - yMin) * iy / gridDensity;
                        const calcMinR = Math.max(constraints.minRadius, 10);
                        const calcMaxR = Math.min(constraints.maxRadius, Math.sqrt(centerX * centerX + centerY * centerY) + H);

                        if (calcMinR >= calcMaxR) continue;

                        for (let ir = 0; ir < 5; ir++) {
                            const radius = calcMinR + (calcMaxR - calcMinR) * ir / 4;
                            const result = calculateBishopFOS(centerX, centerY, radius, profile, poreParams, numSlices);

                            if (!result.valid) continue;

                            const entryOK = result.entryX >= limits.toeMin && result.entryX <= limits.toeMax;
                            const exitOK = result.exitX >= (xCrest + limits.crestMin) && result.exitX <= (xCrest + limits.crestMax);
                            const geometryOK = result.entryX < result.exitX;
                            const depthOK = result.maxDepth <= constraints.maxDepth;

                            if (entryOK && exitOK && geometryOK && depthOK && result.fos < bestFos) {
                                bestFos = result.fos;
                                bestResult = result;
                            }
                        }
                    }
                }

                results.push({
                    paramValue: paramValue,
                    fos: bestFos === Infinity ? null : bestFos,
                    isBaseline: Math.abs(paramValue - originalValue) < stepSize * 0.1
                });
            }

            // Restore original value
            config.setValue(originalValue);
            
            // Restore original pore pressure model if we changed it
            if ((paramKey === 'waterTable' || paramKey === 'ruCoeff') && originalPPModel === 'none') {
                document.getElementById('porePressureModel').value = 'none';
                updatePorePressureUI();
            }

            // Display results
            displaySensitivityResults(results, config, originalValue);
        }

        function displaySensitivityResults(results, config, baselineValue) {
            document.getElementById('sensitivityResults').style.display = 'block';

            // Find baseline FoS
            const baselineResult = results.find(r => r.isBaseline) || results[Math.floor(results.length / 2)];
            const baselineFos = baselineResult ? baselineResult.fos : null;

            // Update table header
            document.getElementById('sensitivityParamHeader').textContent = config.label;

            // Populate table
            const tbody = document.getElementById('sensitivityTableBody');
            tbody.innerHTML = '';

            results.forEach(r => {
                if (r.fos === null) return;

                const change = baselineFos ? ((r.fos - baselineFos) / baselineFos * 100) : 0;
                const changeStr = change >= 0 ? `+${change.toFixed(1)}%` : `${change.toFixed(1)}%`;
                const status = r.fos >= 1.5 ? 'safe' : r.fos >= 1.3 ? 'warning' : 'danger';
                const statusText = r.fos >= 1.5 ? '‚úì Safe' : r.fos >= 1.3 ? '‚ö† Marginal' : '‚úó Unsafe';

                const row = document.createElement('tr');
                if (r.isBaseline) row.className = 'baseline';
                row.innerHTML = `
                    <td>${r.paramValue.toFixed(1)} ${config.unit}</td>
                    <td>${r.fos.toFixed(3)}</td>
                    <td style="color: ${change >= 0 ? 'var(--accent-safe)' : 'var(--accent-danger)'}">${changeStr}</td>
                    <td class="status-${status}">${statusText}</td>
                `;
                tbody.appendChild(row);
            });

            // Calculate statistics
            const validResults = results.filter(r => r.fos !== null);
            const fosValues = validResults.map(r => r.fos);
            const minFos = Math.min(...fosValues);
            const maxFos = Math.max(...fosValues);
            const avgFos = fosValues.reduce((a, b) => a + b, 0) / fosValues.length;

            // Sensitivity gradient (change in FoS per unit change in parameter)
            const paramRange = validResults[validResults.length - 1].paramValue - validResults[0].paramValue;
            const fosRange = maxFos - minFos;
            const gradient = fosRange / paramRange;

            // Find critical threshold (where FoS = 1.3 and 1.5)
            let threshold13 = null;
            let threshold15 = null;
            for (let i = 0; i < validResults.length - 1; i++) {
                const r1 = validResults[i];
                const r2 = validResults[i + 1];
                if ((r1.fos < 1.3 && r2.fos >= 1.3) || (r1.fos >= 1.3 && r2.fos < 1.3)) {
                    threshold13 = r1.paramValue + (1.3 - r1.fos) / (r2.fos - r1.fos) * (r2.paramValue - r1.paramValue);
                }
                if ((r1.fos < 1.5 && r2.fos >= 1.5) || (r1.fos >= 1.5 && r2.fos < 1.5)) {
                    threshold15 = r1.paramValue + (1.5 - r1.fos) / (r2.fos - r1.fos) * (r2.paramValue - r1.paramValue);
                }
            }

            // Update summary
            document.getElementById('sensitivitySummary').innerHTML = `
                <div class="title">Analysis Summary</div>
                <div class="stat">
                    <span class="stat-label">Parameter Range</span>
                    <span class="stat-value">${validResults[0].paramValue.toFixed(1)} - ${validResults[validResults.length-1].paramValue.toFixed(1)} ${config.unit}</span>
                </div>
                <div class="stat">
                    <span class="stat-label">FoS Range</span>
                    <span class="stat-value">${minFos.toFixed(3)} - ${maxFos.toFixed(3)}</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Baseline Value</span>
                    <span class="stat-value">${baselineValue.toFixed(1)} ${config.unit} ‚Üí FoS ${baselineFos ? baselineFos.toFixed(3) : 'N/A'}</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Sensitivity</span>
                    <span class="stat-value">${(gradient * 10).toFixed(4)} ŒîFoS per 10 ${config.unit}</span>
                </div>
                ${threshold13 !== null ? `<div class="stat">
                    <span class="stat-label">FoS = 1.3 Threshold</span>
                    <span class="stat-value" style="color: var(--accent-warning)">${threshold13.toFixed(1)} ${config.unit}</span>
                </div>` : ''}
                ${threshold15 !== null ? `<div class="stat">
                    <span class="stat-label">FoS = 1.5 Threshold</span>
                    <span class="stat-value" style="color: var(--accent-safe)">${threshold15.toFixed(1)} ${config.unit}</span>
                </div>` : ''}
            `;

            // Draw chart
            drawSensitivityChart(validResults, config, baselineValue, baselineFos);
        }

        function drawSensitivityChart(results, config, baselineValue, baselineFos) {
            const canvas = document.getElementById('sensitivityChart');
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            const margin = { top: 40, right: 60, bottom: 50, left: 70 };
            const width = canvas.width - margin.left - margin.right;
            const height = canvas.height - margin.top - margin.bottom;

            // Calculate scales
            const paramValues = results.map(r => r.paramValue);
            const fosValues = results.map(r => r.fos);
            const paramMin = Math.min(...paramValues);
            const paramMax = Math.max(...paramValues);
            const fosMin = Math.min(...fosValues, 1.0) * 0.95;
            const fosMax = Math.max(...fosValues, 1.5) * 1.05;

            const scaleX = width / (paramMax - paramMin);
            const scaleY = height / (fosMax - fosMin);

            const toX = v => margin.left + (v - paramMin) * scaleX;
            const toY = v => margin.top + (fosMax - v) * scaleY;

            // Draw grid
            ctx.strokeStyle = 'rgba(169, 177, 214, 0.1)';
            ctx.lineWidth = 1;

            // Horizontal grid lines
            const fosStep = (fosMax - fosMin) / 5;
            for (let i = 0; i <= 5; i++) {
                const fos = fosMin + i * fosStep;
                ctx.beginPath();
                ctx.moveTo(margin.left, toY(fos));
                ctx.lineTo(margin.left + width, toY(fos));
                ctx.stroke();
            }

            // Draw threshold lines
            // FoS = 1.5 line
            if (fosMin < 1.5 && fosMax > 1.5) {
                ctx.strokeStyle = 'rgba(158, 206, 106, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(margin.left, toY(1.5));
                ctx.lineTo(margin.left + width, toY(1.5));
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#9ece6a';
                ctx.font = '10px JetBrains Mono';
                ctx.fillText('FoS = 1.5', margin.left + width + 5, toY(1.5) + 4);
            }

            // FoS = 1.3 line
            if (fosMin < 1.3 && fosMax > 1.3) {
                ctx.strokeStyle = 'rgba(224, 175, 104, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(margin.left, toY(1.3));
                ctx.lineTo(margin.left + width, toY(1.3));
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#e0af68';
                ctx.font = '10px JetBrains Mono';
                ctx.fillText('FoS = 1.3', margin.left + width + 5, toY(1.3) + 4);
            }

            // FoS = 1.0 line
            if (fosMin < 1.0 && fosMax > 1.0) {
                ctx.strokeStyle = 'rgba(247, 118, 142, 0.5)';
                ctx.lineWidth = 2;
                ctx.setLineDash([8, 4]);
                ctx.beginPath();
                ctx.moveTo(margin.left, toY(1.0));
                ctx.lineTo(margin.left + width, toY(1.0));
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.fillStyle = '#f7768e';
                ctx.font = '10px JetBrains Mono';
                ctx.fillText('FoS = 1.0', margin.left + width + 5, toY(1.0) + 4);
            }

            // Draw curve with gradient coloring
            ctx.lineWidth = 3;
            for (let i = 0; i < results.length - 1; i++) {
                const r1 = results[i];
                const r2 = results[i + 1];
                const avgFos = (r1.fos + r2.fos) / 2;

                if (avgFos >= 1.5) ctx.strokeStyle = '#9ece6a';
                else if (avgFos >= 1.3) ctx.strokeStyle = '#e0af68';
                else ctx.strokeStyle = '#f7768e';

                ctx.beginPath();
                ctx.moveTo(toX(r1.paramValue), toY(r1.fos));
                ctx.lineTo(toX(r2.paramValue), toY(r2.fos));
                ctx.stroke();
            }

            // Draw data points
            results.forEach(r => {
                const x = toX(r.paramValue);
                const y = toY(r.fos);

                ctx.fillStyle = r.fos >= 1.5 ? '#9ece6a' : r.fos >= 1.3 ? '#e0af68' : '#f7768e';
                ctx.beginPath();
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();

                // Highlight baseline point
                if (r.isBaseline) {
                    ctx.strokeStyle = '#bb9af7';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 9, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });

            // Draw axes
            ctx.strokeStyle = '#565f89';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin.left, margin.top);
            ctx.lineTo(margin.left, margin.top + height);
            ctx.lineTo(margin.left + width, margin.top + height);
            ctx.stroke();

            // Axis labels
            ctx.fillStyle = '#a9b1d6';
            ctx.font = '11px JetBrains Mono';
            ctx.textAlign = 'center';

            // X-axis label
            ctx.fillText(config.label, margin.left + width / 2, canvas.height - 10);

            // X-axis tick labels
            ctx.font = '9px JetBrains Mono';
            const paramStep = (paramMax - paramMin) / 5;
            for (let i = 0; i <= 5; i++) {
                const val = paramMin + i * paramStep;
                ctx.fillText(val.toFixed(0), toX(val), margin.top + height + 20);
            }

            // Y-axis label
            ctx.save();
            ctx.translate(15, margin.top + height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.font = '11px JetBrains Mono';
            ctx.fillText('Factor of Safety', 0, 0);
            ctx.restore();

            // Y-axis tick labels
            ctx.font = '9px JetBrains Mono';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const fos = fosMin + i * fosStep;
                ctx.fillText(fos.toFixed(2), margin.left - 8, toY(fos) + 4);
            }

            // Title
            ctx.fillStyle = '#c0caf5';
            ctx.font = 'bold 13px JetBrains Mono';
            ctx.textAlign = 'center';
            ctx.fillText(`Sensitivity: ${config.label} vs Factor of Safety`, canvas.width / 2, 20);
        }

        // ============================================
        // CSV EXPORT/IMPORT FUNCTIONS
        // ============================================
        
        function getAllParameters() {
            // Collect all input parameters into an object
            const params = {
                // Metadata
                exportDate: new Date().toISOString(),
                version: '1.0',
                
                // Geometry
                slopeHeight: document.getElementById('slopeHeight').value,
                slopeAngle: document.getElementById('slopeAngle').value,
                advancedMode: advancedMode,
                
                // Material (simple mode)
                materialType: document.getElementById('materialType').value,
                cohesion: document.getElementById('cohesion').value,
                frictionAngle: document.getElementById('frictionAngle').value,
                unitWeight: document.getElementById('unitWeight').value,
                
                // Hydrogeology
                porePressureModel: document.getElementById('porePressureModel').value,
                waterTable: document.getElementById('waterTable').value,
                ruCoeff: document.getElementById('ruCoeff').value,
                
                // Constraints
                maxDepthPercent: document.getElementById('maxDepthPercent').value,
                minRadius: document.getElementById('minRadius').value,
                maxRadius: document.getElementById('maxRadius').value,
                
                // Search zones
                toeMin: document.getElementById('toeMin').value,
                toeMax: document.getElementById('toeMax').value,
                crestMin: document.getElementById('crestMin').value,
                crestMax: document.getElementById('crestMax').value,
                
                // Analysis settings
                numSlices: document.getElementById('numSlices').value,
                gridDensity: document.getElementById('gridDensity').value,
                
                // Segments (if advanced mode)
                segmentCount: segments.length,
                segments: JSON.stringify(segments)
            };
            
            return params;
        }
        
        function exportCSV() {
            const params = getAllParameters();
            
            // Create CSV content with parameter name, value pairs
            let csv = 'Parameter,Value\n';
            for (const [key, value] of Object.entries(params)) {
                // Escape values that might contain commas or quotes
                let escapedValue = String(value);
                if (escapedValue.includes(',') || escapedValue.includes('"') || escapedValue.includes('\n')) {
                    escapedValue = '"' + escapedValue.replace(/"/g, '""') + '"';
                }
                csv += `${key},${escapedValue}\n`;
            }
            
            // Add analysis results if available
            if (lastAnalysisResult) {
                const c = lastAnalysisResult.critical;
                csv += '\n# Analysis Results\n';
                csv += `result_fos,${c.fos.toFixed(4)}\n`;
                csv += `result_entryX,${c.entryX.toFixed(2)}\n`;
                csv += `result_exitX,${c.exitX.toFixed(2)}\n`;
                csv += `result_maxDepth,${c.maxDepth.toFixed(2)}\n`;
                csv += `result_radius,${c.radius.toFixed(2)}\n`;
                csv += `result_centerX,${c.centerX.toFixed(2)}\n`;
                csv += `result_centerY,${c.centerY.toFixed(2)}\n`;
                csv += `result_arcLength,${c.totalArcLength.toFixed(2)}\n`;
                csv += `result_totalWeight,${c.totalWeight.toFixed(2)}\n`;
            }
            
            // Create and trigger download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `slope_analysis_${new Date().toISOString().slice(0,10)}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const csv = e.target.result;
                    const lines = csv.split('\n');
                    const params = {};
                    
                    for (const line of lines) {
                        // Skip empty lines and comments
                        if (!line.trim() || line.startsWith('#')) continue;
                        
                        // Parse CSV line (handle quoted values)
                        let [key, ...valueParts] = line.split(',');
                        if (!key || key === 'Parameter') continue;
                        
                        let value = valueParts.join(',').trim();
                        // Remove surrounding quotes if present
                        if (value.startsWith('"') && value.endsWith('"')) {
                            value = value.slice(1, -1).replace(/""/g, '"');
                        }
                        
                        params[key.trim()] = value;
                    }
                    
                    applyImportedParameters(params);
                    alert('Parameters imported successfully!\nClick "Execute Analysis" to run with imported settings.');
                    
                } catch (err) {
                    alert('Error importing CSV: ' + err.message);
                }
            };
            reader.readAsText(file);
            
            // Reset file input so same file can be imported again
            event.target.value = '';
        }
        
        function applyImportedParameters(params) {
            // Apply geometry
            if (params.slopeHeight) document.getElementById('slopeHeight').value = params.slopeHeight;
            if (params.slopeAngle) {
                document.getElementById('slopeAngle').value = params.slopeAngle;
                document.getElementById('slopeAngleValue').textContent = params.slopeAngle + '¬∞';
            }
            
            // Apply material
            if (params.materialType) document.getElementById('materialType').value = params.materialType;
            if (params.cohesion) document.getElementById('cohesion').value = params.cohesion;
            if (params.frictionAngle) {
                document.getElementById('frictionAngle').value = params.frictionAngle;
                document.getElementById('frictionAngleValue').textContent = params.frictionAngle + '¬∞';
            }
            if (params.unitWeight) document.getElementById('unitWeight').value = params.unitWeight;
            
            // Apply hydrogeology
            if (params.porePressureModel) {
                document.getElementById('porePressureModel').value = params.porePressureModel;
                updatePorePressureUI();
            }
            if (params.waterTable) {
                document.getElementById('waterTable').value = params.waterTable;
                document.getElementById('waterTableValue').textContent = params.waterTable + ' ft';
            }
            if (params.ruCoeff) {
                document.getElementById('ruCoeff').value = params.ruCoeff;
                document.getElementById('ruValue').textContent = params.ruCoeff;
            }
            
            // Apply constraints
            if (params.maxDepthPercent) document.getElementById('maxDepthPercent').value = params.maxDepthPercent;
            if (params.minRadius) document.getElementById('minRadius').value = params.minRadius;
            if (params.maxRadius) document.getElementById('maxRadius').value = params.maxRadius;
            
            // Apply search zones
            if (params.toeMin) document.getElementById('toeMin').value = params.toeMin;
            if (params.toeMax) document.getElementById('toeMax').value = params.toeMax;
            if (params.crestMin) document.getElementById('crestMin').value = params.crestMin;
            if (params.crestMax) document.getElementById('crestMax').value = params.crestMax;
            
            // Apply analysis settings
            if (params.numSlices) {
                document.getElementById('numSlices').value = params.numSlices;
                document.getElementById('numSlicesValue').textContent = params.numSlices;
            }
            if (params.gridDensity) {
                document.getElementById('gridDensity').value = params.gridDensity;
                document.getElementById('gridDensityValue').textContent = params.gridDensity;
            }
            
            // Apply segments if advanced mode
            if (params.advancedMode === 'true' && params.segments) {
                try {
                    const importedSegments = JSON.parse(params.segments);
                    if (importedSegments.length > 0) {
                        // Enable advanced mode
                        if (!advancedMode) toggleAdvanced();
                        
                        // Clear existing segments
                        segments = [];
                        document.getElementById('segmentsContainer').innerHTML = '';
                        segmentIdCounter = 0;
                        
                        // Add imported segments
                        for (const seg of importedSegments) {
                            addSegment();
                            const lastId = segmentIdCounter - 1;
                            const lastSeg = segments[segments.length - 1];
                            
                            // Apply segment properties
                            Object.assign(lastSeg, seg);
                            lastSeg.id = lastId;
                            
                            // Update segment UI
                            updateSegmentUI(lastId, seg);
                        }
                    }
                } catch (e) {
                    console.warn('Could not import segments:', e);
                }
            }
            
            // Update all displays
            updateConstraintDisplay();
            updateLimitDisplay('toe');
            updateLimitDisplay('crest');
            updateHeightIndicator();
        }
        
        function updateSegmentUI(id, seg) {
            const el = (suffix) => document.getElementById(`seg${id}_${suffix}`);
            if (el('benchHeight')) el('benchHeight').value = seg.benchHeight || 50;
            if (el('benchFaceAngle')) {
                el('benchFaceAngle').value = seg.benchFaceAngle || 65;
                const label = document.getElementById(`seg${id}_benchFaceAngleValue`);
                if (label) label.textContent = (seg.benchFaceAngle || 65) + '¬∞';
            }
            if (el('catchBenchWidth')) el('catchBenchWidth').value = seg.catchBenchWidth || 25;
            if (el('numBenches')) el('numBenches').value = seg.numBenches || 1;
            if (el('cohesion')) el('cohesion').value = seg.cohesion || 300;
            if (el('frictionAngle')) {
                el('frictionAngle').value = seg.frictionAngle || 30;
                const label = document.getElementById(`seg${id}_frictionAngleValue`);
                if (label) label.textContent = (seg.frictionAngle || 30) + '¬∞';
            }
            if (el('unitWeight')) el('unitWeight').value = seg.unitWeight || 125;
        }

        // ============================================
        // PDF EXPORT FUNCTION
        // ============================================
        
        async function exportPDF() {
            if (!lastAnalysisResult) {
                alert('Please run an analysis first.');
                return;
            }
            
            // Create a new window for the PDF content
            const printWindow = window.open('', '_blank');
            if (!printWindow) {
                alert('Please allow popups to generate PDF report.');
                return;
            }
            
            const params = getAllParameters();
            const c = lastAnalysisResult.critical;
            const profile = lastAnalysisResult.profile;
            const poreParams = getPorePressureParams();
            
            // Generate the cross-section visualization as a data URL
            const vizDataUrl = await generatePDFVisualization();
            
            // Calculate additional values
            const area = c.slices.reduce((sum, s) => sum + s.width * s.height, 0);
            const failureWidth = parseFloat(document.getElementById('failureWidth').value) || 100;
            const volume = area * failureWidth / 27;
            const tonnage = (c.totalWeight / 2000) * failureWidth;
            
            // FoS status
            let fosStatus, fosColor;
            if (c.fos < 1.0) { fosStatus = 'CRITICAL'; fosColor = '#f7768e'; }
            else if (c.fos < 1.3) { fosStatus = 'UNSTABLE'; fosColor = '#f7768e'; }
            else if (c.fos < 1.5) { fosStatus = 'MARGINAL'; fosColor = '#e0af68'; }
            else { fosStatus = 'ACCEPTABLE'; fosColor = '#9ece6a'; }
            
            // Pore pressure description
            let ppDesc = 'None (Dry)';
            if (poreParams.model === 'watertable') ppDesc = `Water Table at ${poreParams.waterTableDepth} ft below crest`;
            else if (poreParams.model === 'ru') ppDesc = `Ru = ${poreParams.ru}`;
            else if (poreParams.model === 'combined') ppDesc = `Water Table at ${poreParams.waterTableDepth} ft + Ru = ${poreParams.ru}`;
            
            const html = `
<!DOCTYPE html>
<html>
<head>
    <title>Slope Stability Analysis Report</title>
    <style>
        @page { 
            size: letter portrait;
            margin: 0.5in;
        }
        * { box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 10pt;
            color: #1a1b26;
            line-height: 1.4;
            margin: 0;
            padding: 20px;
            background: white;
        }
        .header {
            text-align: center;
            border-bottom: 3px solid #1a1b26;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }
        .header h1 {
            margin: 0;
            font-size: 18pt;
            color: #1a1b26;
        }
        .header .subtitle {
            font-size: 10pt;
            color: #565f89;
            margin-top: 5px;
        }
        .header .date {
            font-size: 9pt;
            color: #787c99;
            margin-top: 8px;
        }
        
        .fos-banner {
            background: ${fosColor}15;
            border: 2px solid ${fosColor};
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            margin-bottom: 20px;
        }
        .fos-banner .label {
            font-size: 10pt;
            color: #565f89;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .fos-banner .value {
            font-size: 36pt;
            font-weight: bold;
            color: ${fosColor};
            margin: 5px 0;
        }
        .fos-banner .status {
            font-size: 11pt;
            font-weight: 600;
            color: ${fosColor};
        }
        
        .visualization {
            text-align: center;
            margin: 20px 0;
            page-break-inside: avoid;
        }
        .visualization img {
            max-width: 100%;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .visualization .caption {
            font-size: 9pt;
            color: #565f89;
            margin-top: 8px;
        }
        
        .two-column {
            display: flex;
            gap: 20px;
            margin-bottom: 15px;
        }
        .column {
            flex: 1;
        }
        
        .section {
            margin-bottom: 15px;
            page-break-inside: avoid;
        }
        .section-header {
            font-size: 11pt;
            font-weight: bold;
            color: #1a1b26;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }
        
        .param-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 9pt;
        }
        .param-table td {
            padding: 4px 8px;
            border-bottom: 1px solid #eee;
        }
        .param-table td:first-child {
            color: #565f89;
            width: 55%;
        }
        .param-table td:last-child {
            font-weight: 600;
            text-align: right;
        }
        
        .result-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }
        .result-item {
            background: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
        }
        .result-item .label {
            font-size: 8pt;
            color: #565f89;
        }
        .result-item .value {
            font-size: 11pt;
            font-weight: 600;
        }
        
        .footer {
            margin-top: 30px;
            padding-top: 15px;
            border-top: 1px solid #ccc;
            font-size: 8pt;
            color: #787c99;
            text-align: center;
        }
        
        .forces-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 9pt;
            margin-top: 10px;
        }
        .forces-table th, .forces-table td {
            padding: 5px;
            border: 1px solid #ddd;
            text-align: right;
        }
        .forces-table th {
            background: #f0f0f0;
            font-weight: 600;
        }
        .forces-table td:first-child {
            text-align: left;
        }
        
        @media print {
            body { padding: 0; }
            .no-print { display: none; }
        }
        
        .company-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 3px solid #00d4aa;
            padding-bottom: 15px;
            margin-bottom: 15px;
        }
        .company-logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .company-logo svg {
            width: 50px;
            height: 50px;
        }
        .company-info {
            display: flex;
            flex-direction: column;
        }
        .company-name {
            font-size: 14pt;
            font-weight: bold;
            color: #1a1a1a;
        }
        .company-tagline {
            font-size: 9pt;
            color: #00a080;
            letter-spacing: 0.5px;
        }
        .report-title {
            text-align: right;
        }
        .report-title h1 {
            font-size: 16pt;
            margin: 0;
            color: #1a1a1a;
        }
        .report-title .subtitle {
            font-size: 9pt;
            color: #666;
        }
        .report-title .date {
            font-size: 8pt;
            color: #888;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="company-header">
        <div class="company-logo">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAABCGlDQ1BJQ0MgUHJvZmlsZQAAeJxjYGA8wQAELAYMDLl5JUVB7k4KEZFRCuwPGBiBEAwSk4sLGHADoKpv1yBqL+viUYcLcKakFicD6Q9ArFIEtBxopAiQLZIOYWuA2EkQtg2IXV5SUAJkB4DYRSFBzkB2CpCtkY7ETkJiJxcUgdT3ANk2uTmlyQh3M/Ck5oUGA2kOIJZhKGYIYnBncAL5H6IkfxEDg8VXBgbmCQixpJkMDNtbGRgkbiHEVBYwMPC3MDBsO48QQ4RJQWJRIliIBYiZ0tIYGD4tZ2DgjWRgEL7AwMAVDQsIHG5TALvNnSEfCNMZchhSgSKeDHkMyQx6QJYRgwGDIYMZAKbWPz9HbOBQAAAQYElEQVR4nO1ce2xT5f9+zq33rWu7McFEjaJmQgJBozjCiBEDSiTiJRgQUGBzlM0M4mDRdU7GLgIDAwKTKYyFEQkwLoYFE2MMBCSKECOoCAiIiqPr/bK25/b9w997fisb2I71EumTNGmW7vT085z3+VzflxoxYoSMDFIGOtU3cKcjQ0CKkSEgxcgQkGJkCEgxMgSkGBkCUowMASlGhoAUI0NAipEhIMXIEJBiZAhIMTIEpBhsqm8gmWAYJu7/kWUZkiQl4G7+wR1DAE3T8Hg8EEURFEXF9D+yLINlWej1+oTd13+eAIqiIMsyAoEAnn32WeTl5UEQhH8lgRj/2rVrOHbsGBiGgSwPfe/qjiDA5/Ph3XffxbJlyyBJUkwrQBRFsCyLH3/8Ec8880zC7u8/TQDLsnA6nVi4cCGWLVsGl8sVMwGyLIPjONTU1CASiUClUkEUxaG/xyG/4i1AUZTyul1IknRLSWAYBm63GxMmTEBTUxM8Hg9omgZN/3vgJwgCLBYLmpubcfjwYeTn50MQhNu+54FAJaMpT4weCoUgCEJMGnwryLIMnU4HjuMGJIGmaQiCAI7jcPDgQRQUFCAYDMZkfFEUodfr8dtvv2Hq1KmIRCIJ038gCSuApmlEIhFEIhGMHDkSw4cPh8ViiSsaISBGoCgKJ0+ehMPhAMuyUcbp63S3bt2KsWPHKp+L5foMw4Dnebz99ttwu90wGo0JkR6ChBJA0zTC4TBycnKwYsUKTJ06FWq1GhqNZtBPFM/zUKvVaGhowMqVK5Wopu93ut1uNDU14eWXX4bT6YzJ+MA/T7/FYkFlZSW++uorDBs2LGHSQ5BQAiRJAsdx+OSTT1BUVAS3241wOIze3t5BXY84xuvXr6Orqwt6vT4qSWJZFg6HA/PmzYPVaoXT6Yw5+RJFETk5OTh48CBaW1uRm5ubcOMDCfQBDMPA6/Vi0qRJ2Lt3L9xuN1iWvS3tJ0aaN28eOjs7o4zEMAz8fj8KCgpw6NAh0DQdV8TDsiwCgQAmT56Mv//+GxqNJqEZMEHCa0Esy0IQBDAMc1vGFwQBZrMZLS0t2L9/P3JzcxVtpigKkiSBpmk0NjbCYDCA5/mYv08URRgMBjQ2NuLSpUvQ6XRJMT6QBCcsy3JM0cetIAgCTCYTPvvsM9hsNsUxEj9C0zQcDgdWrVqFoqKiuHXfZDLh0KFD2LZtG0wmU1KkhyDtq6GSJEGv1+PixYtYtmyZImPE+CzLwuVy4a233sKiRYsUqYsFsixDpVLB4XDAZrNBpVIl8qcMiLQmgKweQRCwdOlSeL1eqNVqRR4YhoHP58Po0aNRVVWFQCAQl8xJkgStVovq6mqcP38eer0+YfH+zZDWBIiiCKPRiIaGBnz55ZdRMTlFURBFESqVCs3NzdBqteB5HgBiMiKRtX379mHnzp0wmUzgeT5DAAEpB+zZswcfffTRgPG+y+WCzWZDYWEhfD5fzCEnkR673Y6GhgZotdqkG54gLQkQRRFZWVk4ffo0li5dCp1OF2Ugovtz585FaWlpXE637/Xr6+tx/vz5pEY9NyLtCCBPp9frxaJFixAIBPrpPon3Gxoa0NvbG1eURVbW7t270dbWpkhPqpB2BEiSBJ1Oh3feeQdnz55FVlZWlO4LggCWZfHhhx8iKysLkUgkrnhfr9fj3LlzqK6uvq2SyFAhrQjgeR5msxmtra3YuXMnLBZLP933+Xyoq6sblO5zHIdwOAyr1Yru7u6kZbu3QtoQQAphnZ2dqKmpQU5ODgRBgCzLSqmA1HlKSkri1n0Sci5fvhwnTpxQrp9qpAUBoigiOzsb3377LRYvXgyKokDTtCIPRPdHjRqF2tpa+Hy+uHXfbDajo6MD7e3tSSu0xYKUEyCKIrRaLf766y8sWLAAPM9DpVIp0kBRFHieh0ajwYYNG2A0GsHzfMwEkIjn5MmTWLFiRcLr+/EipQQQaQmHw3j99dfx559/Qq/XR9V5KIpCOBzG6tWr8cQTT8Dr9Sodqn9zoCSiIn1ht9utdNFS7XwJUkqAJEnIzs5GXV0dTpw4AaPRGCUNHMehp6cHxcXFmDVrVsydrb7XNxgMqKurw6+//hoVUaULUkYA0eW6ujps2bKlX6ZLmupPPvkkli9fDo/HE9dkmyiKMJvNOHDgADo6OvpFVOmClBBAkqEdO3Zg1apVyMnJGVB27rrrLrS2tiqyFM9Em0ajwfnz51FVVZUW8f7NkPS5IFJgO3LkCCorK5GVlQUguoBG0zR6e3uxdu1aPPDAA3FLD6mi+v3+uCOmZCOpd0Yy0YsXL2L+/PlKNfNmuHr16qC+h6ZpBINBjBkzBhs3bkQgEIAsy0MyjzTUSBoBpEEfCASwYMECOJ1OGAwG+P1++P3+qH4xaRE2Nzfj888/H5R+Ex8yffp0NDY2IhAIpOVKSOod6fV6VFVV4fTp0zCbzXA4HHj00Ucxbdo0OByOKCdL0zQYhsGbb76Jo0ePDipzZRgGLpcLVqsV8+fPR3d3NziOG+qfdVtIOAGyLCsRT3V1NTo6OpCfnw+3242HHnoIbW1t2L59O1544QW4XC7FQCSG53keJSUluHz58qDCSDKWXltbi+eeew49PT1x+ZNEI6EEEN3V6XRobW1VGiu9vb3QaDRoaWlBbm4ufD4fPv30Uzz99NOw2+2KgUiW3N3djZkzZ+LatWvQ6XRxkUAmJhiGQXt7O4qKitKKhIQRQCKRUCiEAwcO4L333kNWVhYkSUI4HMb69esxbtw4+Hw+AP8Ye+PGjcrfiF6TUsIvv/wCq9WKcDjcbxzx30Am9FiWxccff4yCggIlo041Ej6cK8sywuEw1Go1VCoVenp6sHLlSlRUVMDhcCiS09fQ06dPR29vb9RQLMdxsNvtmDlzJlpbW+H1euNyqqSXYDQacebMGTz//PMIhUJRzZ5UIOE+gKIoaLVaxfjV1dWoqKhQysl9x0u8Xi8KCgrw4IMPIhQKRYWNPM8jNzcXu3btwtq1a+Oe3yGDtx6PB6NHj8aOHTuUobFUhqdJiYIYhoHD4cDMmTNRWVkJl8vV7+klUwpff/01zpw5o/SB+xqHOPP6+nrs2bMHFosl7nYiy7LweDwoKirC6tWr+xGdbCRcghiGQSAQwD333IPDhw/DYDAgEolEEUCGr65cuYJp06bB7XZDrVZDlmXwPB8VGZE5IZqmsXXrVkyePDmuYSxibEJmZWUlNm7ciGHDhqWkN5xQAoju0jSNXbt2Yfz48fB6vVHGIgmaJEmYMWMGTp06hezsbIiiqNSDuru7wbKs0qQhTlWj0eDQoUN45JFH4iIBQJRveeWVV3DkyJGUFOwSLkGiKKKlpQUTJ07sZ3xiTI7jMH/+fJw8eRJGoxEAEAgEMH78eKVm1DcykiQJGo0Gvb29mDVrFs6dOweDwRB3eEokrrW1FWPHjoXf7096ZJQwAkgx7PHHH8e0adPgcrn6PaGyLMNoNMJms6GrqwsmkwmSJCEUCmH48OHYvHkz1Go1KisrUVFRgZ6enqioSafT4ffff8e8efPg9Xqh1WrjIoGEyfn5+di0aRN0Ol1c3bahQMK+iTxhGo1mwGUtCAJycnKwadMmbN68OapPGwqFUF9fjxEjRiAYDMLtdsNms+Gll17C9evXFRLINS5cuIA5c+YgEAhAo9HERQKJjEaNGoX169crfoCm6aQ454RTPdAmCZ7nYbFYsHfvXlRVVSEnJ0fJVh0OB+rr6zFjxoyoFmIkEsG6deswceLEqPI0ie2PHTuG2bNnK1l2PCSwLAu3240ZM2agpqYGTqcTAP4bBNwIMo//xRdfoKKiQukH0DQNu92OxYsXw2q1wuVyKXpM0zR4noder8fOnTsxYcKEqLqRIAjIzc3FN998g9deew2hUCiqsR8LyJ7i8vJy1NbWwuPxDP2PHwBJJUAQBBgMBpw9exbFxcXgeR4MwygbLKxWKxobG+H1evs9faRJo9Vq0dHRgcLCQjidToUEsqqOHDmCJUuWQKPRRI22xAJSPa2srERZWVlSyhVJI4A0Y65fvx6l1xRFwel0orS0FKtWrVJqQwMtf4ZhEAqFoNVqsWPHDhQWFsLj8ShyxPM88vLy0NnZifLycmi12qjNHLGAoigEAgGUl5fj7rvvjmv0cTBICgGSJEGlUsHv92PhwoW4fPky9Hq9Yvy5c+dizZo18Hq9AG6tvYQEg8GAtrY23HfffVEjiqTf3N7ejoqKCmX0PFYSSPWU47ikTE0npR9A0zQ0Gg3Kyspw9OhRmEwmZT/vuHHj0NDQAJ/PF3PbkGEYBINBmEwmZeIhGAxGkZCXl4e2tjasXr0aJpMp7qa8JEn/ehzCUCDh/QCVSgWVSoWysjJ0dXUhLy8PsizD7/fj/vvvx7Zt25SDMOKJv/uOqW/atAkMw0SVOAgJTU1NWLNmjZJjxLMSkoGEEUCy1YsXL+LVV1/Frl27lHAzEonAYDCgpaUF9957b8znONwIErlMnjwZ27dvhyiKUeMrZF/x+++/P+iVkGgktCGjUqnwxx9/4PDhwzAajZAkCTzPQxAEbNu2DY899ljcNZwbQaamp0yZgvr6evj9fsXIRPtNJhNqa2vR3NyszCCly4REwiWI4zhkZ2cryz8SiWDt2rWYNGlS3CPmNwMhobi4GB988AGCwaByQgshwWKxwGazYcuWLTCbzYhEIkPwC28fSXHCRN+9Xi9sNhvmzJkTFcMPBQgJpaWlqKqqgt1uV5wyIcFsNqOmpgb79u1LmxH1pIShZGfLU089hcWLFyslhqEGSaSWLFmC8vJypcFPTj4k+w5KSkrQ2dmZFps0kkZAOBzGuHHjwHFc4k6f+j/ZCQaDaGpqgtVqhd1ujypjcxwHjuNQWlqK48ePp5yEpCViarUa33//PURRhFqthiAIStRy44ucqkVeN/vcQJ8ljt7lcqGhoQElJSVwu92KHEmSpEzhFRcXD6qXMJRIypFlwP/LUFlZGWw22y2nEW4MSW+WyQ4UuvZN5sj72bNno6urK2qwiwwBjBkzBvv37wfLssoJKyTbnjJlCq5evaq0RxOBpE0nkc0SGzZswPHjx/Hiiy8iKysLWq2235zPpUuXEA6Hlf7viBEjoo45I9n1lStXlC4WIWnkyJFwu93o7u6GVqvFww8/PGCThZSxT506hbKyMrS0tChnDAGI+YC/20VSx8NkWUZ2djZ++OEHfPfdd8qTemNMTnZHEmOTiumN6LungKAvGcQn3KyuQxrzu3fvRl5eHtatW6f0AoLBYNybwAeDpM/nkY3YtzoO+EZCbrX8b/bZvlXQm53/TKYu8vPz0d7ejlGjRuGNN94AwzD46aefYLfboVKpEpo9J80HpDMIWeFwGIWFhRg2bBh+/vlnXLhw4aZHYw7Zd2cI+AdEagKBAARBgEajScrYYnqMCKcBiKFJnyLRx9YTZAi4Acke1E2/PTt3GDIEpBgZAlKMDAEpRoaAFCNDQIqRISDFyBCQYmQISDEyBKQYLK1UcykAcuZ9kt+zvjAASvrnjzIDUDIAMfM+Se/ZA9Yn0+JJuDPfy2AnPZyHDFIHVgyl7uDqDACWSZMh1TsV/wOBNJ4aX3S00AAAAABJRU5ErkJggg==" style="width: 50px; height: 50px; border-radius: 4px;">
            <div class="company-info">
                <span class="company-name">Keefner Mining & Geotech LLC</span>
                <span class="company-tagline">Geotechnical Engineering Services</span>
            </div>
        </div>
        <div class="report-title">
            <h1>Slope Stability Analysis</h1>
            <div class="subtitle">Modified Bishop's Simplified Method</div>
            <div class="date">Generated: ${new Date().toLocaleString()}</div>
        </div>
    </div>
    
    <div class="fos-banner">
        <div class="label">Factor of Safety</div>
        <div class="value">${c.fos.toFixed(3)}</div>
        <div class="status">${fosStatus}</div>
    </div>
    
    <div class="visualization">
        <img src="${vizDataUrl}" alt="Cross Section Visualization">
        <div class="caption">Critical Failure Surface - Cross Section View</div>
    </div>
    
    <div class="two-column">
        <div class="column">
            <div class="section">
                <div class="section-header">üìê Slope Geometry</div>
                <table class="param-table">
                    <tr><td>Overall Slope Height (H)</td><td>${params.slopeHeight} ft</td></tr>
                    <tr><td>Overall Slope Angle (Œ≤)</td><td>${params.slopeAngle}¬∞</td></tr>
                    <tr><td>Horizontal Extent</td><td>${profile.xCrest.toFixed(1)} ft</td></tr>
                </table>
            </div>
            
            <div class="section">
                <div class="section-header">ü™® Material Properties</div>
                <table class="param-table">
                    <tr><td>Cohesion (c')</td><td>${params.cohesion} psf</td></tr>
                    <tr><td>Friction Angle (œÜ')</td><td>${params.frictionAngle}¬∞</td></tr>
                    <tr><td>Unit Weight (Œ≥)</td><td>${params.unitWeight} pcf</td></tr>
                </table>
            </div>
            
            <div class="section">
                <div class="section-header">üíß Hydrogeology</div>
                <table class="param-table">
                    <tr><td>Pore Pressure Model</td><td>${ppDesc}</td></tr>
                </table>
            </div>
        </div>
        
        <div class="column">
            <div class="section">
                <div class="section-header">üéØ Critical Surface Geometry</div>
                <table class="param-table">
                    <tr><td>Entry Point</td><td>${c.entryX >= 0 ? '+' : ''}${c.entryX.toFixed(1)} ft from toe</td></tr>
                    <tr><td>Exit Point</td><td>${(c.exitX - profile.xCrest) >= 0 ? '+' : ''}${(c.exitX - profile.xCrest).toFixed(1)} ft from crest</td></tr>
                    <tr><td>Maximum Depth</td><td>${c.maxDepth.toFixed(1)} ft</td></tr>
                    <tr><td>Arc Length</td><td>${c.totalArcLength.toFixed(0)} ft</td></tr>
                    <tr><td>Circle Radius</td><td>${c.radius.toFixed(1)} ft</td></tr>
                    <tr><td>Circle Center</td><td>(${c.centerX.toFixed(0)}, ${c.centerY.toFixed(0)})</td></tr>
                </table>
            </div>
            
            <div class="section">
                <div class="section-header">üìä Failure Mass Estimation</div>
                <table class="param-table">
                    <tr><td>Cross-Section Area</td><td>${area.toFixed(0)} ft¬≤</td></tr>
                    <tr><td>Slide Weight (2D)</td><td>${(c.totalWeight / 2000).toFixed(0)} tons/ft</td></tr>
                    <tr><td>Assumed Width</td><td>${failureWidth} ft</td></tr>
                    <tr><td>Estimated Volume</td><td>${Math.round(volume).toLocaleString()} yd¬≥</td></tr>
                    <tr><td>Estimated Tonnage</td><td>${Math.round(tonnage).toLocaleString()} tons</td></tr>
                </table>
            </div>
        </div>
    </div>
    
    <div class="section">
        <div class="section-header">‚öñÔ∏è Force Summary</div>
        <table class="forces-table">
            <tr>
                <th>Component</th>
                <th>Value</th>
                <th>Unit</th>
            </tr>
            <tr>
                <td>Total Resisting Force (Œ£ Resisting)</td>
                <td>${c.sumResisting.toFixed(0)}</td>
                <td>lb/ft</td>
            </tr>
            <tr>
                <td>Total Driving Force (Œ£ Driving)</td>
                <td>${c.sumDriving.toFixed(0)}</td>
                <td>lb/ft</td>
            </tr>
            <tr>
                <td>Factor of Safety (Œ£ Resisting / Œ£ Driving)</td>
                <td style="color: ${fosColor}; font-weight: bold;">${c.fos.toFixed(4)}</td>
                <td>-</td>
            </tr>
        </table>
    </div>
    
    <div class="section">
        <div class="section-header">‚öôÔ∏è Analysis Parameters</div>
        <div class="two-column" style="margin-bottom: 0;">
            <div class="column">
                <table class="param-table">
                    <tr><td>Number of Slices</td><td>${params.numSlices}</td></tr>
                    <tr><td>Grid Density</td><td>${params.gridDensity}</td></tr>
                    <tr><td>Max Search Depth</td><td>${params.maxDepthPercent}% of H</td></tr>
                </table>
            </div>
            <div class="column">
                <table class="param-table">
                    <tr><td>Radius Range</td><td>${params.minRadius} - ${params.maxRadius} ft</td></tr>
                    <tr><td>Entry Zone</td><td>${params.toeMin} to ${params.toeMax} ft</td></tr>
                    <tr><td>Exit Zone</td><td>${params.crestMin} to ${params.crestMax} ft</td></tr>
                </table>
            </div>
        </div>
    </div>
    
    <div class="footer">
        <p><strong>Keefner Mining & Geotech LLC</strong> | Slope Stability Analysis Report</p>
        <p>This report is for engineering reference only. Results should be verified by a qualified geotechnical engineer.</p>
        <p style="font-size: 7pt; margin-top: 8px;">Analysis performed using Modified Bishop's Simplified Method</p>
    </div>
    
    <div class="no-print" style="text-align: center; margin-top: 20px;">
        <button onclick="window.print()" style="padding: 10px 30px; font-size: 14px; cursor: pointer;">
            üñ®Ô∏è Print / Save as PDF
        </button>
    </div>
</body>
</html>`;
            
            printWindow.document.write(html);
            printWindow.document.close();
        }
        
        function generatePDFVisualization() {
            return new Promise((resolve) => {
                // Create an offscreen canvas for high-quality PDF output
                const canvas = document.createElement('canvas');
                canvas.width = 1200;
                canvas.height = 700;
                const ctx = canvas.getContext('2d');
                
                // White background for PDF
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                if (!lastAnalysisResult) {
                    resolve(canvas.toDataURL('image/png'));
                    return;
                }
                
                const { critical, profile } = lastAnalysisResult;
                const poreParams = getPorePressureParams();
                const limits = getLimits();
                const H = profile.totalHeight;
                const xCrest = profile.xCrest;
                
                const margin = 60;
                
                // Calculate bounds
                let minX = Math.min(limits.toeMin - 20, critical.entryX - 30, -20);
                let maxX = Math.max(xCrest + limits.crestMax + 20, critical.exitX + 30, xCrest + 50);
                let minY = -H * 0.1;
                let maxY = H * 1.15;
                
                // Extend to show full circle if needed
                minY = Math.min(minY, critical.centerY - critical.radius - 10);
                
                const scaleX = (canvas.width - 2 * margin) / (maxX - minX);
                const scaleY = (canvas.height - 2 * margin) / (maxY - minY);
                const scale = Math.min(scaleX, scaleY);
                
                const offX = margin + (canvas.width - 2 * margin - (maxX - minX) * scale) / 2;
                const offY = margin + (canvas.height - 2 * margin - (maxY - minY) * scale) / 2;
                
                const toX = x => offX + (x - minX) * scale;
                const toY = y => canvas.height - offY - (y - minY) * scale;
                
                // Draw grid
                ctx.strokeStyle = '#e0e0e0';
                ctx.lineWidth = 0.5;
                const gridSpacing = 50;
                for (let x = Math.floor(minX / gridSpacing) * gridSpacing; x <= maxX; x += gridSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(toX(x), toY(minY));
                    ctx.lineTo(toX(x), toY(maxY));
                    ctx.stroke();
                }
                for (let y = Math.floor(minY / gridSpacing) * gridSpacing; y <= maxY; y += gridSpacing) {
                    ctx.beginPath();
                    ctx.moveTo(toX(minX), toY(y));
                    ctx.lineTo(toX(maxX), toY(y));
                    ctx.stroke();
                }
                
                // Ground line (datum)
                ctx.strokeStyle = '#888888';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(toX(minX), toY(0));
                ctx.lineTo(toX(maxX), toY(0));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Fill slope body
                ctx.fillStyle = 'rgba(180, 180, 180, 0.2)';
                ctx.beginPath();
                ctx.moveTo(toX(0), toY(0));
                for (const p of profile.points) {
                    ctx.lineTo(toX(p.x), toY(p.y));
                }
                ctx.lineTo(toX(xCrest), toY(0));
                ctx.closePath();
                ctx.fill();
                
                // Slope profile
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 2.5;
                ctx.beginPath();
                ctx.moveTo(toX(minX), toY(0));
                ctx.lineTo(toX(0), toY(0));
                for (const p of profile.points) {
                    ctx.lineTo(toX(p.x), toY(p.y));
                }
                ctx.lineTo(toX(maxX), toY(H));
                ctx.stroke();
                
                // Water table
                if (poreParams.model === 'watertable' || poreParams.model === 'combined') {
                    const wY = H - poreParams.waterTableDepth;
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([8, 4]);
                    ctx.beginPath();
                    ctx.moveTo(toX(minX), toY(wY));
                    ctx.lineTo(toX(maxX), toY(wY));
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    ctx.fillStyle = '#3b82f6';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText('‚ñº Water Table', toX(minX) + 5, toY(wY) - 5);
                }
                
                // Critical failure surface - fill
                ctx.fillStyle = 'rgba(239, 68, 68, 0.25)';
                ctx.beginPath();
                ctx.moveTo(toX(critical.entryX), toY(critical.entryY));
                
                const entryAngle = Math.atan2(critical.entryY - critical.centerY, critical.entryX - critical.centerX);
                const exitAngle = Math.atan2(critical.exitY - critical.centerY, critical.exitX - critical.centerX);
                
                // Draw arc portion below surface
                for (let a = entryAngle; a <= exitAngle; a += 0.02) {
                    const ax = critical.centerX + critical.radius * Math.cos(a);
                    const ay = critical.centerY + critical.radius * Math.sin(a);
                    ctx.lineTo(toX(ax), toY(ay));
                }
                ctx.lineTo(toX(critical.exitX), toY(critical.exitY));
                
                // Close along surface
                for (let i = profile.points.length - 1; i >= 0; i--) {
                    const p = profile.points[i];
                    if (p.x >= critical.entryX && p.x <= critical.exitX) {
                        ctx.lineTo(toX(p.x), toY(p.y));
                    }
                }
                ctx.closePath();
                ctx.fill();
                
                // Critical failure arc
                ctx.strokeStyle = '#dc2626';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const rad = critical.radius * scale;
                ctx.arc(toX(critical.centerX), toY(critical.centerY), rad, -exitAngle, -entryAngle, false);
                ctx.stroke();
                
                // Entry and exit points
                ctx.fillStyle = '#dc2626';
                ctx.beginPath();
                ctx.arc(toX(critical.entryX), toY(critical.entryY), 6, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.arc(toX(critical.exitX), toY(critical.exitY), 6, 0, Math.PI * 2);
                ctx.fill();
                
                // Circle center
                ctx.fillStyle = '#7c3aed';
                ctx.beginPath();
                ctx.arc(toX(critical.centerX), toY(critical.centerY), 5, 0, Math.PI * 2);
                ctx.fill();
                
                // Radius line
                ctx.strokeStyle = '#7c3aed';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(toX(critical.centerX), toY(critical.centerY));
                const rAngle = (entryAngle + exitAngle) / 2;
                ctx.lineTo(toX(critical.centerX + critical.radius * Math.cos(rAngle)), 
                          toY(critical.centerY + critical.radius * Math.sin(rAngle)));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Max depth indicator
                const depthX = (critical.entryX + critical.exitX) / 2;
                const surfaceY = getSurfaceY(depthX, profile);
                const deepestY = critical.centerY - critical.radius;
                
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 3]);
                ctx.beginPath();
                ctx.moveTo(toX(depthX), toY(surfaceY));
                ctx.lineTo(toX(depthX), toY(surfaceY - critical.maxDepth));
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Labels
                ctx.fillStyle = '#1a1a1a';
                ctx.font = 'bold 14px Arial';
                
                // FoS label
                ctx.fillStyle = '#dc2626';
                ctx.font = 'bold 18px Arial';
                const fosLabelX = (critical.entryX + critical.exitX) / 2;
                const fosLabelY = critical.centerY + 20;
                ctx.fillText(`FoS = ${critical.fos.toFixed(3)}`, toX(fosLabelX) - 50, toY(fosLabelY));
                
                // Height label
                ctx.fillStyle = '#333333';
                ctx.font = 'bold 13px Arial';
                ctx.fillText(`H = ${H.toFixed(0)} ft`, toX(-15), toY(H/2));
                
                // Toe and Crest labels
                ctx.fillStyle = '#059669';
                ctx.font = 'bold 12px Arial';
                ctx.fillText('TOE', toX(0) - 15, toY(0) + 25);
                ctx.fillText('CREST', toX(xCrest) - 20, toY(H) - 10);
                
                // Entry/Exit labels
                ctx.fillStyle = '#dc2626';
                ctx.font = '11px Arial';
                ctx.fillText(`Entry: ${critical.entryX.toFixed(1)} ft`, toX(critical.entryX) - 30, toY(critical.entryY) + 25);
                ctx.fillText(`Exit: ${critical.exitX.toFixed(1)} ft`, toX(critical.exitX) - 20, toY(critical.exitY) - 15);
                
                // Depth label
                ctx.fillStyle = '#f59e0b';
                ctx.font = '11px Arial';
                ctx.fillText(`Depth: ${critical.maxDepth.toFixed(1)} ft`, toX(depthX) + 10, toY(surfaceY - critical.maxDepth/2));
                
                // Radius label
                ctx.fillStyle = '#7c3aed';
                ctx.font = '11px Arial';
                ctx.fillText(`R = ${critical.radius.toFixed(0)} ft`, toX(critical.centerX) + 10, toY(critical.centerY) - 10);
                
                // Scale bar
                const scaleBarLength = 100;
                const scaleBarY = toY(minY) + 30;
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(margin, scaleBarY);
                ctx.lineTo(margin + scaleBarLength * scale, scaleBarY);
                ctx.stroke();
                
                // Scale bar ticks
                ctx.beginPath();
                ctx.moveTo(margin, scaleBarY - 5);
                ctx.lineTo(margin, scaleBarY + 5);
                ctx.moveTo(margin + scaleBarLength * scale, scaleBarY - 5);
                ctx.lineTo(margin + scaleBarLength * scale, scaleBarY + 5);
                ctx.stroke();
                
                ctx.fillStyle = '#333333';
                ctx.font = '11px Arial';
                ctx.fillText(`${scaleBarLength} ft`, margin + (scaleBarLength * scale)/2 - 20, scaleBarY + 20);
                
                resolve(canvas.toDataURL('image/png'));
            });
        }
        
        // Enable PDF export after analysis
        function enablePDFExport() {
            const btn = document.getElementById('pdfExportBtn');
            if (btn) {
                btn.disabled = false;
                document.querySelector('.io-hint').textContent = 'Analysis complete - exports available';
            }
        }

        // Register Service Worker for PWA
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('./sw.js')
                .then(reg => console.log('Service Worker registered:', reg.scope))
                .catch(err => console.log('Service Worker registration failed:', err));
        }

        // Initialize
        window.addEventListener('load', () => {
            updateHeightIndicator();
            updateLimitDisplay('toe');
            updateLimitDisplay('crest');
            updateSensitivityRange();
            initCanvasInteraction();
            setTimeout(runAnalysis, 500);
        });
    </script>
</body>
</html>
